<!DOCTYPE html>

<html lang="en">
<head>

<!-- =================================== START OF  Google tag  ===================================== -->

	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-7997H1319B"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	
	  gtag('config', 'G-7997H1319B');
	</script>
<!-- =================================== END OF  Google tag  ===================================== -->

	
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Differential Gene Expression Analysis  
        in Atopic Dermatitis 
        Using DESeq2
    </title>

	<!-- ===================================  favicon icon ===================================== -->
 <!--   favicon icon: This line below adds a favicon to the tab of the web browser. 
    The favicon is the small icon displayed next to the page title in the browser tab.
    The 'href' attribute specifies the path to the icon file hosted on GitHub. -->

    <link rel="icon" type="image/x-icon" href="https://mohammadrezamohajeri.github.io/Breast-Cancer-Gene-Expression-Biomarker-Analysis/Images/1.ico"> 
    	<!-- ===================================================================================== -->

	
	<!-- =================================== Code Block Styling with Prism.js ===================================== -->
    <!--  Prism.js CSS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.5.0/prism-dracula.min.css" rel="stylesheet">
	<!-- =================================== Code Block Styling with Prism.js ===================================== -->

	
    <style>


/*  =============================================================================================================   */ 
/*  ====================== To highlight the figure or caption when a user clicks on the link:  ================   */ 
	    /*  ====================== Step 1: Add a CSS class for highlighting  ================   */ 
       
        .highlight {
	    animation: highlightAnimation 5s ease-out;
	  }
	
	  @keyframes highlightAnimation {
	    from {
	      background-color: yellow;
	    }
	    to {
	      background-color: transparent;
	    }
	  }
       
/*  =============================================================================================================   */ 



	    
	/*  =================== the text color when is selected  ==============   */ 
	    /* To change the color of text selection on a webpage (like the blue or yellow highlight  ), 
		we can use the ::selection CSS pseudo-element. */ 
		::selection {
			background-color: yellow; /* Change this to any color you prefer */
			color: black; /* Change the text color if needed */
		}
	/*  ===================================================================   */ 

	    
        /* Basic Styles */
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
	    text-align: justify; /* Justify text globally */
        }

        /* Header Style */
        .header {
            font-size: 25px;
            background-color: #01031f;
            color: white;
            height: 350px; /* Set an explicit height */
            padding: 10px 0;
            text-align: center;
            position: relative; /* Add relative positioning here */
        }

        /* Home Link Style */
        .home-link {
            position: absolute;
            bottom: 10px;
            left: 10px;
            text-decoration: none; /* Remove underline */
            z-index: 1; /* Ensures it appears above other content */
        }

        /* Title Style */
        .title {
            font-size: 26px;
            font-weight: bold;
            margin: 20px 0;
            text-align: center;
        }

        /* Explanation Text Style */
        .explanation {
            font-size: 24px; /* Increased explanation font size */
            margin-bottom: 20px;

        }



	    
/*  ============ To increase the space above the headings ========== */
        /* Heading Margin Adjustments to Reduce Space */
	h3, h4, h5 {
	    margin-top: 60px; /* Reduced space above */
	    margin-bottom: 5px; /* Reduced space below */
        }


        .code-caption {
	    font-size: 16px; /* Slightly smaller than body text, but still readable */
	    font-style: italic;
	    margin-bottom: 1px; /* Reduce the bottom margin */
	    color: #555;
	    text-align: justify;
	}

	 	    

        /* Code Block Style */
        .code-block {
            margin-bottom: 20px;
            font-size: 16px; /* Increased code block font size */
        }

        /* Prism.js Code Block Font Size */
        pre[class*="language-"] {
            font-size: 16px; /* Increase font size for Prism.js code blocks */
        }

	/* Figure Style */
	figure {
	    margin-bottom: 30px; /* Adds margin below the figure to create space */
	}

	/* Adjust ul and li styles */
	ul {
	    margin-top: 0 !important;
	    margin-bottom: 0 !important;
	    padding-left: 20px !important; /* Adjust padding */
	}
	
	li {
	    margin-bottom: 5px !important; /* Adjust space between list items */
	}


  


/* ============== MOBILE RESPONSIVE FIX (start) ============== */
@media only screen and (max-width: 768px) {
	.header {
		height: auto;
		padding: 20px 10px;
	}

	.header h1 {
		font-size: 22px;
		line-height: 1.4;
		padding: 10px;
	}

	.title {
		font-size: 20px;
		margin: 20px 10px;
	}

	.explanation {
		font-size: 18px;
		padding: 0 10px;
	}

	body {
		margin: 10px;
	}
}
/* ============== MOBILE RESPONSIVE FIX (end) ============== */	    

    </style>
</head>
<body>

    <div class="header">

        <!-- the positioning of the "Home" icon -->
        <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/index.html" class="home-link">
            <img src="Pictures/Home_Link_JPG/1.jpg" alt="Home" style="width:50px; height:auto;">
        </a>
        
        <h1>Differential Gene Expression Analysis <br>
            in Atopic Dermatitis  <br>
            Using DESeq2</h1>
    </div>
    

    
    
    <div class="body">

       		 <!-- ============== A horizontal line ================== -->
		<!-- Add a horizontal line above the introduction -->
		<hr style="border: none; border-top: 1px solid black; margin: 20px 0;">
		 <!-- =================================================== -->

        
        <!-- ================================================================== -->
        <div class="explanation">
          <h3>Introduction to Differential Gene Expression in Atopic Dermatitis (AD) Patients</h3>
          <ul>
	    <li>  
               In this analysis, we perform <strong>Differential Gene Expression (DEG) analysis</strong> using the <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4878611/" target="_blank"><strong>DESeq2</strong></a> package on the <strong><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE157194" target="_blank">GSE157194</a></strong> dataset, which consists of RNA-seq data from patients with <strong>Atopic Dermatitis (AD)</strong>. This dataset includes a total of <strong>166 samples</strong> obtained from <strong>57 patients</strong> with moderate to severe AD, prior to and after systemic treatment.
            </li>
	  </ul>

		
       
	       
	   
		
          <h4>Dataset Overview:</h4>
          <ul>
            <li><strong><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE157194" target="_blank">GSE157194</a></strong>: RNA-seq data from AD patients.</li>
            <li><strong>111 samples before treatment</strong>: Includes <strong>lesional (AL)</strong> and <strong>non-lesional (AN)</strong> skin biopsies. Non-lesional samples were taken at least 5 cm from the active lesion, ensuring that the comparison between these conditions captures the underlying gene expression differences in the disease state before any intervention.</li>
            <li><strong>40 samples post-treatment with Dupilumab</strong> (3 months).</li>
            <li><strong>15 samples post-treatment with Cyclosporine</strong> (3 months).</li>
          </ul>
        
          <h4>Objective of This Analysis:</h4>
          <ul>
	    <li>
              Our primary focus is to conduct a differential expression analysis between the <strong>lesional (AL)</strong> and <strong>non-lesional (AN)</strong> skin samples <strong>before treatment</strong>. This helps in identifying key <strong>differentially expressed genes (DEGs)</strong> and associated <strong>pathways</strong> that <strong><u>distinguish diseased skin from non-diseased skin</u></strong>. Insights gained from this comparison can:
            </li>
           
            <li>Reveal potential <strong>biomarkers</strong> for AD diagnosis and monitoring.</li>
            <li>Highlight novel <strong>therapeutic targets</strong> or <strong>pathways</strong> relevant to AD pathogenesis.</li>
            <li>Provide groundwork for <strong>drug discovery</strong> and personalized medicine by identifying pathways that could respond to specific therapeutic interventions.</li>
          </ul>
        
          <h4>Comprehensive Analysis Approach:</h4>
          <ul>
		  
	  <li>    
            This analysis incorporates various bioinformatics techniques and <strong>visualization tools</strong> (e.g., <strong>PCA</strong>, <strong>volcano plots</strong>, etc.) to ensure a holistic understanding of the gene expression profiles. While some aspects of the analysis may provide standalone insights, the goal is to create a <strong>comprehensive reference</strong> for <strong>DEG analysis using DESeq2</strong>. This can serve as a <strong>functional analysis resource</strong> for future studies.
          </li>

	  </ul>  

		
          <h4>
            In addition to the DEG analysis, we also perform pathway and gene enrichment analysis, including:
          </h4>
		
          <ul>
            <li><strong>KEGG</strong> and <strong>GO term</strong> analyses.</li>
            <li><strong>Gene Set Enrichment Analysis (GSEA)</strong> and <strong>Overrepresentation Analysis (ORA)</strong> to explore the biological processes, molecular functions, and cellular components involved in AD.</li>
          </ul>
		
        </div>


       		 <!-- ============== A horizontal line ================== -->
		<!-- Add a horizontal line above the introduction -->
		<hr style="border: none; border-top: 1px solid black; margin: 20px 0;">
		 <!-- =================================================== -->
	  <!-- ================================================================== -->
	<div class="explanation">
	    <h3>1. Load Necessary Libraries</h3>
	    <p>Before starting the analysis, we need to load the essential R libraries required for <strong>data manipulation</strong>, <strong>visualization</strong>, and performing <strong>differential gene expression (DEG) analysis</strong>.</p>
	</div>
	
	<div class="code-block">
	    <pre><code class="language-r">
	# Load necessary libraries for RNA-seq analysis and visualization
	library(GEOquery)        # Load the GEOquery package to access GEO datasets
	library(DESeq2)          # For differential expression analysis
	library(data.table)      # Efficient data manipulation
	library(umap)            # Dimensionality reduction for visualization
	library(ggplot2)         # General-purpose plotting
	library(clusterProfiler) # For functional enrichment analysis
	library(org.Hs.eg.db)    # Human genome annotations
	library(VennDiagram)     # Venn diagram visualization
	library(knitr)           # Report generation and table formatting (for kable)
	library(tinytex)         # LaTeX support for report generation
	    </code></pre>
	</div>


		 <!-- ============== A horizontal line ================== -->
				<!-- Add a horizontal line above the introduction -->
				<hr style="border: none; border-top: 1px solid black; margin: 20px 0;">
		 <!-- =================================================== -->
	    
	<!-- ================================ 2. ================================== -->
	<div class="explanation">
	    <h3>2. Load and Prepare Data</h3>
		<h4 style="margin-top: 5px;">2.1. Retrieving Data from GEO</h4>

	    <ul>	
		<li>In this step, we download the <strong>raw gene expression data</strong> (count matrix) and  <strong>the sample information</strong> (referred to as <strong>metadata</strong> or <strong>phenotype data</strong>) from the <strong>Gene Expression Omnibus (GEO)</strong> using GEO's accession ID <strong>GSE157194</strong>. The count matrix contains raw gene expression counts, while the phenotype data contains metadata for each sample (such as treatment groups and sample type).</li>
	    </ul>
		
	    <ul>
	        <li>In this code (Code Block 2.1), we begin by downloading and preparing the dataset for analysis. Step 1 involves defining the GEO accession ID (gse_id <- "GSE157194") and using <strong>getGEOSuppFiles()</strong> from the <strong>GEOquery</strong> library to download the supplementary count matrix, which is then loaded into R using <strong>read.table()</strong> after decompressing the .gz file. In Step 2, the phenotype data (metadata) is obtained using <strong>getGEO()</strong> from GEOquery, and stored in metadata. The metadata provides additional descriptive information about the samples in the count matrix. Step 3 prints summary information (  <a href="#figure-2-1" onclick="highlightFigure('2-1')">Figure 2.1</a>), including the number of genes and samples in the count matrix and the number of samples and features in the metadata, after downloading the data from GEO, for a quick overview of the dataset.</li>
	    </ul>
	</div>


	<!-- Caption for the code block -->
	<p class="code-caption">Code Block 2.1. Retrieving Data from GEO</p>
	    
	<div class="code-block">
	    <pre><code class="language-r">
	# ===================================================================
	# Step 1. Download Supplementary Files for the Count Matrix
	# ===================================================================

	# Define the GEO accession ID
	gse_id <- "GSE157194"
	
	# Download the supplementary files for this GEO dataset
	getGEOSuppFiles(gse_id)
	
	# Check the list of files downloaded
	list.files(gse_id)
	
	# ================================
	# Path to the downloaded file
	supp_file_path <- paste0(gse_id, "/", "GSE157194_Raw_gene_counts_matrix.txt.gz")
	
	# Unzip and load the file into R as a data frame (counts matrix)
	counts_matrix <- read.table(gzfile(supp_file_path), header = TRUE, row.names = 1)
 
	# ===================================================================
	# Step 2. Download Phenotype Data
	# ===================================================================
	# Specify the GEO accession number
	gse_id <- "GSE157194"
	
	
	# Download the phenotype data (GEO series matrix)
	gse_data <- getGEO(gse_id, GSEMatrix = TRUE, AnnotGPL = TRUE)
	
	# If multiple series are available, choose the first one
	gse_data <- gse_data[[1]]
	
	# Extract metadata from the GEO dataset
	# We access the metadata (also known as phenotype data) stored in the 'phenoData' slot of the GEO object.
	metadata <- gse_data@phenoData@data
	
	# ===================================================================
	# Step 3. Print Summary Information about the Count Matrix and Metadata
	# ===================================================================
	cat("\n\n# Summary Information of the Count Matrix and Metadata (Post-GEO Download)\n")
	cat("=========================================================\n")
	
	# Count matrix summary
	cat("\nCount Matrix Summary:\n")
	cat("---------------------------------------------------------\n")
	cat("Number of Genes (Rows): ", nrow(counts_matrix), "\n")
	cat("Number of Samples (Columns): ", ncol(counts_matrix), "\n\n")
	
	
	# Metadata summary
	cat("\nMetadata Summary:\n")
	cat("---------------------------------------------------------\n")
	cat("Number of Samples (Rows): ", nrow(metadata), "\n")
	cat("Number of Features (Columns): ", ncol(metadata), "\n\n")
	
	cat("\n=========================================================\n")
			
	    </code></pre>
	</div>

	<!-- Figure 2.1.Summary Information of the Count Matrix and Metadata   -->
	    <figure id="figure-2-1" style="text-align: justify; margin: 10px;">
	        <a href="Pictures/RNA_Seq_Task1/Figure2.1.Summary_Information_of_the_Count_Matrix_Metadata.png" target="_blank">
	            <img src="Pictures/RNA_Seq_Task1/Figure2.1.Summary_Information_of_the_Count_Matrix_Metadata.png" alt="Heatmap 1" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 75%; height: 300px;">
	        </a>
	        <figcaption id="figure-caption-2-1">
			Figure 2.1. Summary Information of the Count Matrix and Metadata (Post-GEO Download). This figure displays the number of genes and samples in the count matrix, as well as the number of samples and features in the metadata after downloading from the GEO dataset.
		</figcaption>
	    </figure>

		
			<!-- ========================================= 2.2 ======================================== -->
			<div class="explanation">
			    <h3>2.2. Preparing Data</h3>
			    <ul>
			        <li><strong>Effective data preparation</strong> is crucial for ensuring high-quality and accurate results in downstream analyses. This step includes identifying and <u>removing potential outlier samples</u> to avoid biases and <u>pre-filtering low-count genes</u> to enhance the overall data quality.</li>
			    </ul>
			    <h4 style="margin-top: 5px;">2.2.1. Identify and Remove Outlier Samples</h4>
			    <ul> 
			        <li><u>Outlier samples</u>, particularly those with significantly <u>low or high library sizes</u>, can introduce biases into the analysis and skew the results. Therefore, it is crucial to identify and remove such samples before conducting further data manipulations to ensure that the remaining data is representative of high-quality samples, allowing for reliable downstream analyses.</li>
			        <li>Traditionally, removing <u>samples below the lower threshold</u> (calculated as Q1 - 1.5 * IQR) is a common practice, as these samples often indicate technical issues, such as failed sequencing or low quality. <u>Samples above the upper threshold</u> (Q3 + 1.5 * IQR) are typically retained, as they are often biologically meaningful (e.g., having high sequencing depth), and removing them could risk discarding valuable information. However, if it can be demonstrated that such samples introduce bias or are clearly problematic, it might be necessary to remove them to maintain data integrity.</li>
			        <li>Based on the <a href="#figure-2-2-1-1" onclick="highlightFigure('2-2-1-1')">dot plot of library sizes</a>, we identified a total of <u>six outlier samples</u> from 166 original samples: three with significantly low counts (Patient_12_AN_m3, Patient_24_AN_m3, Patient_31_AL_m0) and three with significantly high counts (Patient_41_AL_m3, Patient_42_AL_m0, Patient_48_AL_m3). Although <u>the high-count samples</u> might be biologically distinct, <u>their presence could mask potential biomarkers within the majority of the population by over-influencing the analysis</u> . Therefore, to ensure that we focus on <u>identifying biomarkers that are representative of the majority</u>, we have decided to remove both lower and upper threshold outliers.</li>
			        <li>The provided code is written to handle either scenario, allowing users to remove only the lower threshold outliers, or both lower and upper threshold outliers. Comments within the code explain which lines to uncomment or comment out based on the user's chosen approach. In this case, both thresholds are applied to remove the six outlier samples, resulting in a filtered dataset that better represents the core population.</li>
			        <li>Not all the plots presented in the code are necessary to generate; they are provided here to demonstrate different ways of visualizing the effect of removing outlier samples.</li>
			        <li>In this code (<strong>Code Block 2.2.1</strong>), we begin with <strong>Step 1</strong>, which involves <u>calculating the library sizes for each sample</u> using <strong>colSums(counts_matrix)</strong>. This operation returns the total count of all reads for each sample. The summary statistics (<strong>summary(library_sizes)</strong>) is then printed to provide an overview of the data distribution (Min= 9,628,756, 1st Qu=20,647,659, Median=22,896,256, Mean=23,218,539, 3rd Qu= 25,719,325, Max= 43,076,805). Next, in <strong>Step 1.1</strong>, we set <u>two thresholds for outlier identification</u>, using <strong>quantiles</strong> (Q) and the <strong>interquartile</strong> range (IQR). The first quartile (<strong>quantile(library_sizes, 0.25)</strong>) and the third quartile (<strong>quantile(library_sizes, 0.75)</strong>) represent the 25th and 75th percentiles of the data, respectively. The IQR (<strong>IQR(library_sizes)</strong>) indicates the spread of the central 50% of the data and helps to assess data variability. We then calculate the lower threshold as <strong>Q1 - 1.5 * IQR</strong>, which targets low outliers that may indicate poor-quality or problematic samples. Optionally, the upper threshold is calculated as <strong>Q3 + 1.5 * IQR</strong> to identify samples with unusually high counts, which may also be removed if deemed necessary. In <strong>Step 1.2</strong>, depending on the user's choice, either or both thresholds can be used to define outlier samples. These outliers are identified using logical conditions, and their indices are used to remove them from both "counts_matrix" and "metadata", resulting in the creation of filtered versions ("counts_matrix_filtered" and "metadata_filtered") (<strong>Step 3</strong>). After identifying the outliers, in <strong>Step 2</strong>, we store the original dimensions of both "counts_matrix" and "metadata" before filtering. This allows us to compare them against the dimensions after outlier removal, which we store in <strong>Step 3.3</strong>. In <strong>Step 3</strong>, we remove the outlier samples from the "counts_matrix" (<strong>Step 3.1</strong>) and "metadata" (<strong>Step 3.2</strong>), ensuring that the metadata matches the "filtered counts_matrix". After filtering, we reassign the filtered versions back to "counts_matrix" and "metadata" to ensure consistency for subsequent analysis steps (<strong>Step 6</strong>). In <strong>Step 4</strong>, following the removal of outliers, we create various visualizations (dot plot <a href="#figure-2-2-1-1" onclick="highlightFigure('2-2-1-1')">(Figure 2.2.1.1)</a>, bar plot <a href="#figure-2-2-1-2" onclick="highlightFigure('2-2-1-2')">(Figure 2.2.1.2)</a>, boxplot <a href="#figure-2-2-1-3" onclick="highlightFigure('2-2-1-3')">(Figure 2.2.1.3)</a>, density plot <a href="#figure-2-2-1-4" onclick="highlightFigure('2-2-1-4')">(Figure 2.2.1.4)</a>, and violin plot <a href="#figure-2-2-1-5" onclick="highlightFigure('2-2-1-5')">(Figure 2.2.1.5)</a>) to illustrate the changes in library sizes before and after filtering. These visualizations provide insights into the effects of outlier removal on the dataset. Specifically:</li>
			    </ul>
			    <ul>
			        <li><strong>Boxplots</strong> and <strong>Violin plots</strong> are used to compare the distributions of library sizes before and after filtering.</li>
			        <li><strong>Dot plots</strong> annotate specific outlier samples that were removed.</li>
			        <li><strong>Bar plots</strong> allow for a direct comparison of individual sample library sizes before and after filtering.</li>
			        <li><strong>Density plots</strong> provide an overview of the entire distribution of library sizes.</li>
			    </ul>
			    <ul>
			        <li>In <strong>Step 5</strong>, we generate visualizations to confirm the changes in the dimensions of the "counts_matrix" and "metadata" before and after outlier removal using dimensions comparison plot <a href="#figure-2-2-1-6" onclick="highlightFigure('2-2-1-6')">(Figure 2.2.1.6)</a> as well as Summary Information <a href="#figure-2-2-1-7" onclick="highlightFigure('2-2-1-7')">(Figure 2.2.1.7)</a>. To achieve this, we create data frames representing the count matrix dimensions and metadata dimensions, both before and after filtering (<strong>Step 5.1</strong> and <strong>Step 5.2</strong>). These data frames are then used to generate four bar plots, which illustrate the number of genes, samples, and metadata features before and after filtering. These four plots are combined into a single figure using the <Strong>grid.arrange()</Strong> function from the <Strong>gridExtra</Strong> library (<strong>Step 5.3</strong>). This combined visualization provides a clear overview of how filtering affected the dataset dimensions.</li>
			    </ul>
			</div>

			


		
			<!-- Caption for the code block -->
			<p class="code-caption">Code Block 2.2.1: Identifying and Removing Outlier Samples, and Visualizing the Impact</p>
			
			<div class="code-block">
			    <pre><code class="language-r">
	# ========================================================
	# Load necessary libraries
	# ========================================================
	library(ggplot2)
	library(gridExtra) # For arranging multiple plots in one figure
	
	# ========================================================
	# Step 1: Calculate Library Size and Identify Outliers
	# ========================================================
	
	# Calculate library sizes
	library_sizes <- colSums(counts_matrix)
	
	# Optionally, print summary to check for anomalies
	summary(library_sizes)
	
	# Identify potential outlier samples based on library size
	# Step 1.1: Set thresholds for outlier identification
	# Set the lower threshold to identify samples with low counts
	lower_threshold <- quantile(library_sizes, 0.25) - 1.5 * IQR(library_sizes)
	
	# Set the upper threshold to identify samples with very high counts
	upper_threshold <- quantile(library_sizes, 0.75) + 1.5 * IQR(library_sizes)
	
	
	# Step 1.2: Find outlier samples
	# Uncomment the corresponding line depending on whether you want to use:
	# - Only the lower threshold
	# - Only the upper threshold
	# - Both lower and upper thresholds
	
	# Use only the lower threshold:
	# outlier_samples <- colnames(counts_matrix)[library_sizes < lower_threshold]
	
	# Use both lower and upper thresholds:
	outlier_samples <- colnames(counts_matrix)[library_sizes < lower_threshold | library_sizes > upper_threshold]
	
	# ========================================================
	# Step 2: Store Original Dimensions Before Filtering (First  part for Plotting Dimensions of Count Matrix and Metadata)
	# ========================================================
	
	# Store original dimensions before filtering
	counts_matrix_before <- dim(counts_matrix)  # [number of genes, number of samples]
	metadata_before <- dim(metadata)            # [number of samples, number of features]
	
	
	# ========================================================
	# Step 3: Remove Outlier Samples from Data
	# ========================================================
	
	# Step 3.1: Remove outlier samples from counts matrix
	counts_matrix_filtered <- counts_matrix[, !(colnames(counts_matrix) %in% outlier_samples)]
	
	# Step 3.2: Remove outlier samples from metadata
	metadata_filtered <- metadata[colnames(counts_matrix_filtered), ]
	
	# Step 3.3: Store dimensions after filtering (Second part for Plotting Dimensions of Count Matrix and Metadata)
	counts_matrix_after <- dim(counts_matrix_filtered)
	metadata_after <- dim(metadata_filtered)
	
	# Step 3.4: Calculate filtered library sizes
	filtered_library_sizes <- colSums(counts_matrix_filtered)
	
	# ========================================================
	# Step 4: Plot the Filtered Library Sizes (Box, Violin, Dot, Bar, Density plots)
	# ========================================================
	# Step 4.1: Prepare Data for Plotting:
	
	# Combine original and filtered library sizes into a data frame for comparison
	comparison_df <- data.frame(
	  Sample = c(names(library_sizes), names(filtered_library_sizes)),
	  Library_Size = c(library_sizes, filtered_library_sizes),
	  Group = c(rep("Original", length(library_sizes)), rep("Filtered", length(filtered_library_sizes)))
	)
	
	
	# Step 4.2: Boxplot of Library Sizes Before and After Filtering
	box_plot <- ggplot(comparison_df, aes(x = Group, y = Library_Size, fill = Group)) +
	  geom_boxplot() +
	  theme_minimal() +
	  labs(title = "Boxplot of Library Sizes Before and After Removing Outliers",
	       x = "Group", y = "Total Counts per Sample") +
	  theme(legend.position = "none")
	
	ggsave("Figures/2.2.1.Outlier_Samples/Figure2.2.1.3.Box_Plot_Library_Sizes.png", plot = box_plot, width = 8, height = 5, bg = "white")
	
	
	# Step 4.3: Violin Plot of Library Sizes Before and After Filtering
	violin_plot <- ggplot(comparison_df, aes(x = Group, y = Library_Size, fill = Group)) +
	  geom_violin(trim = FALSE, alpha = 0.6) +
	  theme_minimal() +
	  labs(title = "Violin Plot of Library Sizes Before and After Removing Outliers",
	       x = "Group", y = "Total Counts per Sample") +
	  theme(legend.position = "none")
	
	ggsave("Figures/2.2.1.Outlier_Samples/Figure2.2.1.5.Violin_Plot_Library_Sizes.png", plot = violin_plot, width = 8, height = 5, bg = "white")
	
	
	
	# Step 4.4: Dot Plot with Annotation of Outliers
	dot_plot <- ggplot(comparison_df, aes(x = Sample, y = Library_Size, color = Group)) +
	  geom_point() +
	  theme_minimal() +
	  labs(title = "Dot Plot of Library Sizes with Outlier Annotation", 
	       x = "Sample", y = "Total Counts per Sample") +
	  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
	  geom_text(data = subset(comparison_df, Group == "Original" & Sample %in% outlier_samples), 
		    aes(label = Sample), vjust = -1, size = 3, color = "red", angle = 5)
	
	ggsave("Figures/2.2.1.Outlier_Samples/Figure2.2.1.1.Dot_Plot_Library_Sizes.png", plot = dot_plot, width = 10, height = 5, bg = "white")
	
	
	
	# Step 4.5: Comparative Bar Plot Before and After Filtering
	bar_plot <- ggplot(comparison_df, aes(x = Sample, y = Library_Size, fill = Group)) +
	  geom_bar(stat = "identity", position = "dodge") +
	  theme_minimal() +
	  labs(title = "Comparative Bar Plot of Library Sizes Before and After Removing Outliers", 
	       x = "Sample", y = "Total Counts per Sample") +
	  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
	
	ggsave("Figures/2.2.1.Outlier_Samples/Figure2.2.1.2.Bar_Plot_Library_Sizes.png", plot = bar_plot, width = 10, height = 5, bg = "white")
	
	
	
	# Step 4.6: Side-by-Side Density Plot Before and After Filtering
	density_plot <- ggplot(comparison_df, aes(x = Library_Size, fill = Group)) +
	  geom_density(alpha = 0.5) +
	  theme_minimal() +
	  labs(title = "Density Plot of Library Sizes Before and After Removing Outliers", 
	       x = "Total Counts per Sample", y = "Density") +
	  scale_x_log10() +
	  theme(legend.position = "top")
	
	ggsave("Figures/2.2.1.Outlier_Samples/Figure2.2.1.4.Density_Plot_Library_Sizes.png", plot = density_plot, width = 8, height = 5, bg = "white")
	
	
	# ========================================================
	# Step 5: Plot Dimensions of Count Matrix and Metadata (Third  part for Plotting Dimensions of Count Matrix and Metadata)
	# ========================================================
	
	# Step 5.1: Create Data Frames for Count Matrix Dimensions
	counts_matrix_dims <- data.frame(
	  Measure = rep(c("Samples", "Genes"), each = 2),
	  Stage = rep(c("Before Filtering", "After Filtering"), 2),
	  Count = c(counts_matrix_before[2], counts_matrix_after[2],
		    counts_matrix_before[1], counts_matrix_after[1])
	)
	
	# Step 5.2: Create Data Frames for Count Matrix and Metadata Dimensions
	metadata_dims <- data.frame(
	  Measure = rep(c("Samples", "Features"), each = 2),
	  Stage = rep(c("Before Filtering", "After Filtering"), 2),
	  Count = c(metadata_before[1], metadata_after[1],
		    metadata_before[2], metadata_after[2])
	)
	
	
	# Step 5.3: Generate and Combine Plots for Dimensions
	
	# Plot for count matrix samples before and after filtering
	count_samples_plot <- ggplot(subset(counts_matrix_dims, Measure == "Samples"), aes(x = Stage, y = Count, fill = Stage)) +
	  geom_bar(stat = "identity") +
	  geom_text(aes(label = Count), vjust = -0.5) +  # Add count labels on top of bars
	  theme_minimal() +
	  labs(title = "Count Matrix: Number of Samples (Columns)", y = "Samples", x = "") +
	  theme(legend.position = "none") +
	  scale_fill_manual(values = c("Before Filtering" = "#4682B4", "After Filtering" = "#8A2BE2")) # Change colors
	
	# Plot for count matrix genes (transcripts) before and after filtering
	count_genes_plot <- ggplot(subset(counts_matrix_dims, Measure == "Genes"), aes(x = Stage, y = Count, fill = Stage)) +
	  geom_bar(stat = "identity") +
	  geom_text(aes(label = Count), vjust = -0.5) +  # Add count labels on top of bars
	  theme_minimal() +
	  labs(title = "Count Matrix: Number of Genes (Rows)", y = "Genes (Transcripts)", x = "") +
	  theme(legend.position = "none") +
	  scale_fill_manual(values = c("Before Filtering" = "#4682B4", "After Filtering" = "#8A2BE2")) # Change colors
	
	# Plot for metadata samples before and after filtering
	metadata_samples_plot <- ggplot(subset(metadata_dims, Measure == "Samples"), aes(x = Stage, y = Count, fill = Stage)) +
	  geom_bar(stat = "identity") +
	  geom_text(aes(label = Count), vjust = -0.5) +  # Add count labels on top of bars
	  theme_minimal() +
	  labs(title = "Metadata: Number of Samples (Rows)", y = "Count", x = "") +
	  theme(legend.position = "none") +
	  scale_fill_manual(values = c("Before Filtering" = "#32CD32", "After Filtering" = "#FFD700")) # Change colors
	
	# Plot for metadata features before and after filtering
	metadata_features_plot <- ggplot(subset(metadata_dims, Measure == "Features"), aes(x = Stage, y = Count, fill = Stage)) +
	  geom_bar(stat = "identity") +
	  geom_text(aes(label = Count), vjust = -0.5) +  # Add count labels on top of bars
	  theme_minimal() +
	  labs(title = "Metadata: Number of Features (Columns)", y = "Sample Attributes", x = "") +
	  theme(legend.position = "none") + 
	  scale_fill_manual(values = c("Before Filtering" =  "#32CD32", "After Filtering" = "#FFD700")) # Change colors
	
	# Arrange the four plots in a grid
	combined_plot <- grid.arrange(count_samples_plot, count_genes_plot,
				      metadata_samples_plot, metadata_features_plot,
				      ncol = 2)
	
	# Save the combined plot
	ggsave("Figures/2.2.1.Outlier_Samples/Figure2.2.1.6.Dimensions_Comparison.png", plot = combined_plot, width = 12, height = 10, bg = "white")
	
	
	
	# ========================================================
	# Step 6: Reassign Filtered Data
	# ========================================================
	# Reassign filtered versions back to counts_matrix and metadata
	counts_matrix <- counts_matrix_filtered
	metadata <- metadata_filtered
	
	# ======================================
	# Step 7. Print Summary Information about the Count Matrix and Metadata
	# ======================================
	cat("\n\n# Summary Information of the Count Matrix and Metadata (Post-Outlier Removal)\n")
	cat("=========================================================\n")
	
	# Count matrix summary
	cat("\nCount Matrix Summary:\n")
	cat("---------------------------------------------------------\n")
	cat("Number of Genes (Rows): ", nrow(counts_matrix), "\n")
	cat("Number of Samples (Columns): ", ncol(counts_matrix), "\n\n")
	
	
	# Metadata summary
	cat("\nMetadata Summary:\n")
	cat("---------------------------------------------------------\n")
	cat("Number of Samples (Rows): ", nrow(metadata), "\n")
	cat("Number of Features (Columns): ", ncol(metadata), "\n\n")
		
			cat("\n=========================================================\n")
			    </code></pre>
			</div>
			

		

		



 

			 <!-- Figures Row with Click-to-Enlarge Feature -->
			<div style="display: flex; justify-content: space-around;">
			    
			    <!-- Dot Plot (Figure 2.2.1.1) -->
			    <figure id="figure-2-2-1-1" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.1.1.Dot_Plot_Library_Sizes.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.1.1.Dot_Plot_Library_Sizes.png" alt="Dot Plot of Library Sizes with Outlier Annotation" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px; object-fit: contain;">
			
			        </a>
			        <figcaption id="figure-caption-2-2-1-1">
			            <strong>Figure 2.2.1.1.</strong> Dot Plot of Library Sizes with Outlier Annotation. This dot plot visualizes the library sizes for all samples before and after outlier removal. The outlier samples are clearly labeled to show their positions, with the filtered samples marked in red and labeled. It illustrates the rationale behind removing outliers by highlighting samples that significantly deviate from the main distribution.
			        </figcaption>
			    </figure>
			
			    <!-- Bar Plot (Figure 2.2.1.2) -->
			    <figure id="figure-2-2-1-2" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.1.2.Bar_Plot_Library_Sizes.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.1.2.Bar_Plot_Library_Sizes.png" alt="Comparative Bar Plot of Library Sizes" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px; object-fit: contain;">
			        </a>
			        <figcaption id="figure-caption-2-2-1-2">
			            <strong>Figure 2.2.1.2.</strong> Comparative Bar Plot of Library Sizes Before and After Removing Outliers. This bar plot compares the total counts per sample before and after removing the identified outliers. It allows a direct comparison of individual library sizes, illustrating how outlier removal affects the data distribution.
			        </figcaption>
			    </figure>
			
			    <!-- Box Plot (Figure 2.2.1.3) -->
			    <figure id="figure-2-2-1-3" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.1.3.Box_Plot_Library_Sizes.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.1.3.Box_Plot_Library_Sizes.png" alt="Boxplot of Library Sizes" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px; object-fit: contain;">
			        </a>
			        <figcaption id="figure-caption-2-2-1-3">
			            <strong>Figure 2.2.1.3.</strong> Boxplot of Library Sizes Before and After Removing Outliers. This boxplot provides a summary of the library size distributions for the original and filtered datasets. By comparing the interquartile ranges and identifying extreme values, it highlights how removing outliers impacts the spread of the data.
			        </figcaption>
			    </figure>
			
			    <!-- Density Plot (Figure 2.2.1.4) -->
			    <figure id="figure-2-2-1-4" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.1.4.Density_Plot_Library_Sizes.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.1.4.Density_Plot_Library_Sizes.png" alt="Density Plot of Library Sizes" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px; object-fit: contain;">
			        </a>
			        <figcaption id="figure-caption-2-2-1-4">
			            <strong>Figure 2.2.1.4.</strong> Density Plot of Library Sizes Before and After Removing Outliers. The density plot shows the distribution of library sizes across all samples before and after outlier removal. The plot visualizes changes in the overall density, allowing us to observe shifts in data distribution and the effects of filtering extreme values.
			        </figcaption>
			    </figure>
			
			</div>
			
			<div style="display: flex; justify-content: space-around;">
			
			    <!-- Violin Plot (Figure 2.2.1.5) -->
			    <figure id="figure-2-2-1-5" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.1.5.Violin_Plot_Library_Sizes.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.1.5.Violin_Plot_Library_Sizes.png" alt="Violin Plot of Library Sizes" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px; object-fit: contain;">
			        </a>
			        <figcaption id="figure-caption-2-2-1-5">
			            <strong>Figure 2.2.1.5.</strong> Violin Plot of Library Sizes Before and After Removing Outliers. This violin plot combines elements of a boxplot and a density plot to illustrate both the distribution and summary statistics of the library sizes before and after removing outliers. It helps visualize the spread and density of values, showing the differences between the original and filtered groups.
			        </figcaption>
			    </figure>
			
			    <!-- Dimensions Comparison (Figure 2.2.1.6) -->
			    <figure id="figure-2-2-1-6" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.1.6.Dimensions_Comparison.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.1.6.Dimensions_Comparison.png" alt="Dimensions Comparison of Count Matrix and Metadata" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px; object-fit: contain;">
			        </a>
			        <figcaption id="figure-caption-2-2-1-6">
			            <strong>Figure 2.2.1.6.</strong> Dimensions Comparison: Four bar plots showing changes in the count matrix and metadata dimensions before and after outlier removal. Only the number of samples changed, confirming that outliers were removed, while genes and features remained unchanged.
			        </figcaption>
			    </figure>
			
			
			    <!-- Summary Information (Figure 2.2.1.7) -->
			    <figure id="figure-2-2-1-7" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.1.7.Summary_Information_of_the_Count_Matrix_Metadata_After_Removing_Outlier_Samples.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.1.7.Summary_Information_of_the_Count_Matrix_Metadata_After_Removing_Outlier_Samples.png" alt="Summary Information of the Count Matrix and Metadata" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px; object-fit: contain;">
			        </a>
			        <figcaption id="figure-caption-2-2-1-7">
			            <strong>Figure 2.2.1.7.</strong> Summary Information of the Count Matrix and Metadata (Post-Outlier Removal), showing the updated number of genes, samples, and features after removing outlier samples.
			        </figcaption>
			    </figure>
			
			</div>


			<!-- ========================================= 2.2.2 ======================================== -->
			<div class="explanation">
			    <h3>2.2.2. Pre-filtering Low-Count Genes to Improve Data Quality</h3>
			    <ul>
			        <li><strong>Low-count genes</strong>, which are expressed at insufficient levels, can contribute noise and increase the likelihood of false-positive results. Removing these lowly-expressed genes ensures that the analysis focuses on biologically meaningful signals and helps to reduce computational complexity and improve the robustness of downstream analyses.</li>
			        <li>Although <strong>DESeq2</strong> performs <strong>independent filtering</strong> internally during the differential expression step, performing <a href="https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#:~:text=While%20it%20is%20not%20necessary,See%20independent%20filtering%20section." target="_blank"><strong>pre-filtering</strong></a> at this early stage is widely accepted in analyses to improve computational efficiency, reduce memory usage, and remove genes that are unlikely to contribute meaningful biological insights.</li>

			        <li>In this code (<strong>Code Block 2.2.2</strong>), we first (<strong>Step 1</strong>) create a logical matrix to identify genes with sufficient expression (counts â‰¥ 10). Specifically, we retain only those genes that have counts of at least 10 in at least half of the samples (<code>ncol(counts_matrix) / 2</code>). This step ensures that the filtered dataset retains genes with meaningful levels of expression across a significant number of samples. After identifying the genes to keep, we filter the <code>counts_matrix</code> to retain only those genes, reassign the filtered matrix back to <code>counts_matrix</code> (<strong>Step 2</strong>), and then check the dimensions of the filtered dataset (<strong>Step 3</strong>) to confirm the number of genes and samples that remain (<a href="#figure-2-2-2" onclick="highlightFigure('2-2-2')">Figure 2.2.2</a>).</li>
			    </ul>
			</div>
			
			<!-- Caption for the code block -->
			<p class="code-caption"><strong>Code Block 2.2.2:</strong> Pre-filtering Low-Count Genes to Improve Data Quality</p>
			
			<!-- Code Block 2.2.2: Pre-filtering Low-Count Genes to Improve Data Quality -->
			<div class="code-block">
			    <pre><code class="language-r">
			# ========================================================
			# Step 1: Pre-filter low-count genes
			# ========================================================
			
			# Step 1: Create a logical matrix to check if each value in counts_matrix is >= 10 (sufficient expression).
			# Step 2: Retain genes that have counts >= 10 in at least half of the samples (ncol(counts_matrix) / 2). 
			keep_genes <- rowSums(counts_matrix >= 10) >= (ncol(counts_matrix) / 2)
			
			# Filter the counts matrix to retain only the genes that meet the filtering criteria
			filtered_counts_matrix <- counts_matrix[keep_genes, ]
			
			# ========================================================
			# Step 2: Reassign filtered matrix to counts_matrix
			# ========================================================
			
			# Assign the filtered counts matrix back to counts_matrix for consistency in later steps
			counts_matrix <- filtered_counts_matrix
			
			# ======================================
			# Step 3. Check dimensions of the filtered matrix (Summary Information after Low-Count Filtering)
			# ======================================
			cat("\n\n# Summary Information of the Count Matrix and Metadata (Post-Low-Count Filtering)\n")
			cat("=========================================================\n")
			
			# Count matrix summary
			cat("\nCount Matrix Summary:\n")
			cat("---------------------------------------------------------\n")
			cat("Number of Genes (Rows): ", nrow(counts_matrix), "\n")
			cat("Number of Samples (Columns): ", ncol(counts_matrix), "\n\n")
			
			# Metadata summary
			cat("\nMetadata Summary:\n")
			cat("---------------------------------------------------------\n")
			cat("Number of Samples (Rows): ", nrow(metadata), "\n")
			cat("Number of Features (Columns): ", ncol(metadata), "\n\n")
			
			cat("\n=========================================================\n")
			    </code></pre>
			</div>
			
			<!-- Summary Information of the Count Matrix and Metadata (Figure 2.2.2) -->
			<div style="display: flex; justify-content: space-around;">
			    <figure id="figure-2-2-2" style="text-align: justify; margin: 10px;">
			        <a href="Pictures/RNA_Seq_Task1/Figure2.2.2.Summary_Information_of_the_Count_Matrix_Metadata_After_Removing_Low_Count_Genes.png" target="_blank">
			            <img src="Pictures/RNA_Seq_Task1/Figure2.2.2.Summary_Information_of_the_Count_Matrix_Metadata_After_Removing_Low_Count_Genes.png" alt="Summary Information After Removing Low-Count Genes" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 75%; height: 300px;">
			        </a>
			        <figcaption id="figure-caption-2-2-2">
			            <strong>Figure 2.2.2.</strong>Summary Information of the Count Matrix and Metadata (Post-Low-Count Filtering), showing the number of genes, samples, and features after removing low-count genes.
			        </figcaption>
			    </figure>
			</div>





		
 

 		<!-- ============== A horizontal line ================== -->
				<!-- Add a horizontal line above the introduction -->
				<hr style="border: none; border-top: 1px solid black; margin: 20px 0;">
		 <!-- =================================================== -->
		 
			
<!-- ========================================= 3. ======================================== -->
		<div class="explanation">
		    <h3>3. Exploratory Data Analysis (EDA)- Before the "<a href="https://www.bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#the-deseqdataset" target="_blank"><strong>DESeqDataSet</strong></a>" object (dds) Creation</h3>
		    <ul>
	   	      <li>
			<strong>EDA</strong> is essential before performing <strong>DEA</strong> (Differential Expression Analysis) to explore the relationship between samples and to gain insights into the <strong>structure</strong> and <strong>distribution</strong> of the data. This step involves exploring both the <strong>metadata</strong> and the <strong>count matrix</strong> to ensure that the dataset is well-prepared for downstream analysis.		     
		      </li>
		    </ul> 
		</div>
<!-- =================== 3.1. explanation =========================== -->
		<div class="explanation">
		    <h3>3.1. Metadata Exploration</h3>
			<h4 style="margin-top: 5px;">3.1.1. Metadata Overview</h4>
		    <ul>
	   	      <li>
		       We examine the metadata to identify key columns for analysis, such as sample ID, experimental conditions, tissue type, time points, and treatments. Selected columns are then viewed using <strong>View() function</strong> for a quick overview of the samples (Code Block 3.1.1.; <a href="#figure-3-1-1" onclick="highlightFigure('3-1-1')">Figure 3.1.1</a>).
		      </li>
		     </ul> 
		</div>

		
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 3.1.1.  Metadata Exploration</p>
		
		<!-- ======= 3.1. code chunk =========== -->

		<div class="code-block">
		    <pre><code class="language-r">
			
		# View all column names in the metadata to select relevant columns for analysis
		# This step helps us to explore the structure of the metadata and understand which columns are available.		
		colnames(metadata)
		
		# Select relevant columns for analysis based on the experiment
		selected_metadata <- metadata[, c("geo_accession", "title", "source_name_ch1", "characteristics_ch1.2", "characteristics_ch1.3", "timepoint:ch1", "therapy:ch1", "patient id:ch1", "platform_id", "data_processing")]
		
		# Open the selected metadata in a viewer for further exploration
		View(selected_metadata)
		    </code></pre>
		</div>

		
                 <!-- ======== 3.1. image ============= ============================================= -->
		 <!-- =============================================================================== --> 
		<!-- Wrapping the entire figure -->
		<div style="margin-bottom: 30px;">
		    <figure id="figure-3-1-1" style="text-align: justify;">
		        <!-- Add a clickable link to enlarge the image -->
		        <a href="Pictures/RNA_Seq_Task1/Selected_Metadata_GSE157194.png" target="_blank">
		            <img src="Pictures/RNA_Seq_Task1/Selected_Metadata_GSE157194.png" 
		                 alt="Cumulative Variance Plot" 
		                 style="display: block; background-color: #f0f0f0; padding: 20px; border-radius: 15px; 
		                        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px;">
		        </a>
		
			<figcaption id="figure-caption-3-1-1">
		            Figure 3.1.1. Metadata Exploration as Part of Exploratory Data Analysis (EDA) (After filtering outlier samples).
		        </figcaption>
		    </figure>
		</div>
		 <!-- =============================================================================== --> 



		
	<!-- ===================  Check Distribution of Samples Across Key Metadata Variables =========================== -->
	<div class="explanation">
	    <h4 style="margin-top: 10px;">3.1.2. Check Distribution of Samples Across Key Metadata Variables (using table() and kable())</h4>
		<h4 style="margin-top: 5px;">3.1.2.1. Summary of Sample Distribution by Patient Group and Timepoints</h4>
	    <ul>
	        <li>
	            By exploring key <strong>metadata variables</strong> such as <strong>sample type</strong> (e.g., <strong>lesional</strong> vs <strong>non-lesional</strong> or <strong>treated</strong> vs <strong>untreated</strong>), <strong>timepoints</strong> (e.g., <strong>baseline</strong> vs <strong>post-treatment</strong>), and <strong>therapy groups</strong> (e.g., <strong>Cyclosporine</strong> and <strong>Dupilumab</strong>), we gain insights into <strong>the distribution of the samples</strong>  across different conditions. This exploration also helps to ensure that the dataset is well-balanced and appropriately structured for the upcoming <strong>differential expression analysis</strong>. 
	        </li>
		    
	        <li>
		    For example, after filtering out sample outliers, the <strong>source_name_ch1</strong> column in metadata shows the distribution of samples across various experimental conditions (Code Block 3.1.2; <a href="#figure-3-1-2" onclick="highlightFigure('3-1-2')">Figure 3.1.2.1</a> a), such as <strong>baseline samples</strong> (m0) for both lesional (AL) (<strong>m0_AL</strong>: 55 samples) and non-lesional (AN) (<strong>m0_AN</strong>: 54 samples) skin, which are key to our current analysis, as well as samples taken post-treatment with <strong>Cyclosporine</strong> (8 lesional & 6 non-lesional) and <strong>Dupilumab</strong> (19 lesional & 18 non-lesional samples). This data can be useful for exploring treatment effects in future experiments.
	        </li>

		    		    
	        <li>
		    In addition, <strong>characteristics_ch1.2</strong> (Code Block 3.1.2.1; <a href="#figure-3-1-2" onclick="highlightFigure('3-1-2')">Figure 3.1.2.1</a> b) provides information on the <strong>timepoints</strong> (e.g., <strong>baseline</strong> or <strong>post-treatment</strong>). This is crucial for analyzing how gene expression changes over time, particularly in response to therapies like <strong>Cyclosporine</strong> and <strong>Dupilumab</strong>. In this dataset, 51 samples were collected 3 months post-treatment, and 109 samples were collected at baseline.
	        </li>
		    
		    

	    </ul>
	</div>


		<!-- Caption for the code block -->
<p class="code-caption">Code Block 3.1.2.1: Sample Distribution Table Generation</p>
	<!-- ======= 3.3. code chunk =========== -->
	<div class="code-block">
	    <pre><code class="language-r">
# Table of samples by patient group (e.g., lesional vs non-lesional)
group_table <- table(metadata$source_name_ch1)
kable(group_table, format = "html", col.names = c("Patient Group", "Count"))

# Table of samples by timepoints (e.g., baseline vs post-treatment)
timepoint_table <- table(metadata$characteristics_ch1.2)
kable(timepoint_table, format = "html", col.names = c("Timepoint", "Count"))
	    </code></pre>
	</div>


			    <!-- ======= 3.3. image with caption =========== -->	
	<!-- ================================================================================= -->
	<div style="display: flex; justify-content: space-around; align-items: stretch;">
	    <!-- Figure 3.1.2.1. -->
	    <figure id="figure-3-1-2" style="text-align: justify; margin: 10px; flex: 1;">
	        <a href="Pictures/RNA_Seq_Task1/Samples_distribution_GSE157194.png" target="_blank">
	            <img src="Pictures/RNA_Seq_Task1/Samples_distribution_GSE157194.png" alt="Heatmap 1" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
	        </a>
	        <figcaption id="figure-caption-3-1-2">
	            <strong>Figure 3.1.2.1.</strong> Sample distribution by patient group and timepoint (After filtering outlier samples): a. Patient groups (lesional, non-lesional, post-treatment), b. Timepoint distribution (baseline and 3 months post-treatment).
	        </figcaption>
	    </figure>
	
	    <!-- Figure 3.1.2.2 -->
	    <figure id="figure-3-1-2-2" style="text-align: justify; margin: 10px; flex: 1;">
	        <a href="Pictures/RNA_Seq_Task1/Samples_Distribution2_GSE157194.png" target="_blank">
	            <img src="Pictures/RNA_Seq_Task1/Samples_Distribution2_GSE157194.png" alt="Heatmap 2" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
	        </a>
	        <figcaption id="figure-caption-3-1-2-2">
	            <strong>Figure 3.1.2.2.</strong> Sample Distribution by Timepoint and Patient ID (After Filtering Outlier Samples).
	        </figcaption>
	    </figure>
	</div>
			
<!-- ================================================================================= -->



		<div class="explanation">
	<h4 style="margin-top: 5px;">3.1.2.2. Summary of Sample Distribution Across Multiple Metadata Variables</h4>
			
  <ul>
    
    <li>
    Other metadata columns can also be explored (Code Block 3.1.2.2):      
    </li>
    
    <li>
      The <strong>characteristics_ch1.3</strong>  column (<a href="#figure-3-1-2-2" onclick="highlightFigure('3-1-2-2')">Figure 3.1.2.2</a> a) provides information about the treatment each patient received. It shows that 14 samples were treated with Cyclosporine and 37 samples with Dupilumab, while the remaining 109 samples represent baseline conditions (m0_AL and m0_AN combined). This is important for distinguishing between treatment groups when analyzing differential expression across conditions.
    </li>

	  
    <li>
      The <strong>patient id:ch1</strong> column (<a href="#figure-3-1-2-2" onclick="highlightFigure('3-1-2-2')">Figure 3.1.2.2</a> b) helps track individual patients across different conditions. Some patients may have samples from multiple conditions (e.g., lesional, non-lesional, and post-treatment with both Cyclosporine and Dupilumab), allowing for longitudinal analyses within the same individuals. For researchers, this provides an opportunity to focus on patients who have undergone multiple treatments, reducing variability and enhancing the accuracy of comparative analyses.
    </li>
    <li>
      In addition to these, other metadata columns can provide insights into the experimental setup and data processing. For example, <strong>platform_id</strong> shows all utilized platforms (GPL21290 in this experiment), <strong>extract_protocol_ch1</strong> and <strong>extract_protocol_ch1.1</strong> describe how the RNA was extracted and processed in the lab, and how the RNA libraries were prepared for sequencing. Furthermore, <strong>data_processing</strong> and its related fields provide detailed information on how the sequencing data was processed, from basecalling using Illumina software to trimming primers with cutadapt and mapping reads to the human reference genome with Tophat2 and Bowtie2. The use of Samtools to clean and sort the reads, and HTSeq to count reads per gene, ensures the data is accurately prepared for downstream analysis. The genome build used for mapping is GRCh38, and the raw count data is stored in a tab-delimited format.
    </li>
  </ul>
</div>

 

<!-- Caption for the code block 3.1.2.2. -->
<p class="code-caption">Code Block 3.1.2.2. Assessing Sample Characteristics for Experimental Design</p>
		
<!-- =============== 3.1.2.2. Code Chunk ================  -->
<div class="code-block">
  <pre><code class="language-r">

# ======================
# List of all relevant columns
# These columns are selected based on the characteristics of the experiment, 
# including metadata features like source names, patient IDs, and data processing details.
columns <- c("source_name_ch1",              # Source of the sample
             "characteristics_ch1.2",        # Experimental characteristic 1
             "characteristics_ch1.3",        # Experimental characteristic 2
             "therapy:ch1",                  # Therapy information
             "patient id:ch1",               # Patient ID
             "platform_id",                  # Platform used for data generation
             "extract_protocol_ch1",         # Sample extraction protocol 1
             "extract_protocol_ch1.1",       # Sample extraction protocol 2
             "data_processing",              # Data processing detail 1
             "data_processing.1",            # Data processing detail 2
             "data_processing.2",            # Data processing detail 3
             "data_processing.3",            # Data processing detail 4
             "data_processing.4",            # Data processing detail 5
             "data_processing.5",            # Data processing detail 6
             "data_processing.6"             # Data processing detail 7
)

# ==========
# Loop through each column and generate a summary table for each
# The loop checks if each column exists in the 'metadata' dataframe and prints a table of its unique values and frequencies.
for (col in columns) {
  if (col %in% colnames(metadata)) {  # Ensure the column exists in the metadata dataframe
    group_table <- table(metadata[[col]])  # Access and count the occurrences of each unique value in the column
    print(kable(group_table))              # Display the table using kable for a nicely formatted output
  } else {
    print(paste("Column", col, "does not exist in the metadata"))  # Handle cases where the column doesn't exist
  }
}

  </code></pre>
</div>




<!-- ========================================================== -->
	<div class="explanation">
	    <h4>3.1.3. Check Distribution of Samples Across Key Metadata Variables (using bar charts)</h4>
	    <ul>
	        <li>
	            Visualizing the distribution of samples with <strong>bar charts</strong> provides a more intuitive and visual approach compared to table-based summaries. It helps to quickly identify <u>patterns</u>, <u>imbalances</u>, or <u>trends</u> in the data, making it easier to understand the distribution across different experimental conditions or metadata variables.
	        </li>
	    </ul>
	
	    <h4>3.1.3.1. Visualizing Sample Distribution for a Single Metadata Variable Using Bar Charts</h4>
	    <ul>
	        <li>
	            This code (Code Block 3.1.3.1) focuses on visualizing a single variable, such as <code>source_name_ch1</code>, to display the sample distribution by experimental condition (<a href="#figure-3-1-3-1" onclick="highlightFigure('3-1-3-1')">Figure 3.1.3.1</a>). However, the variable can be easily substituted with others if needed. <strong>(Step 1)</strong>: The <code><a href="https://ggplot2.tidyverse.org/" target="_blank">ggplot2</a></code> library is loaded for creating the plot. <strong>(Step 2)</strong>: A bar plot is constructed using <code>geom_bar()</code> to create the bars and <code>geom_text()</code> to add count labels, where <code>..count..</code> refers to the computed count statistic. The plot is styled using <code>theme_minimal()</code> and color is applied with <code>scale_fill_brewer()</code>. <strong>(Step 3)</strong>: Finally, the <code>ggsave()</code> function saves the plot to a specified location.
	        </li>
	    </ul>
	</div>
	
	<!-- Caption for the code block -->
	<p class="code-caption">Code Block 3.1.3.1. Visualizing Sample Distribution by Experimental Condition</p>
	
	<div class="code-block">
	    <pre><code class="language-r">
# ====================================
# Step 1: Load the necessary library
# ====================================
library(ggplot2)

# ============================================
# Step 2: Create a bar plot for sample counts
# ============================================
p <- ggplot(metadata, aes(x = `source_name_ch1`, fill = `source_name_ch1`)) +
  geom_bar() +  # Add bars representing sample counts
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5, size = 3) +  # Add count labels above bars
  theme_minimal() +  # Apply a minimal theme for better readability
  labs(title = "Sample Distribution by Experimental Condition", 
       x = "Source Name", 
       y = "Number of Samples") +
  theme(axis.text.x = element_text(angle = 60, vjust = 0.5, hjust = 0.6, size = 8)) +  # Adjust axis label size and angle
  scale_fill_brewer(palette = "Set3")  # Apply a color palette for the bars

# The variable "source_name_ch1" in this code can be manually replaced by other variables 
# such as "characteristics_ch1.2", "characteristics_ch1.3", or "patient id:ch1" to visualize their distributions.

# ==================================
# Step 3: Save the plot to a file
# ==================================
ggsave("Figures/3.1.3.1.Bar_Chart_Metadata_Variables/3.1.3.1.Sample_Distribution_by_Condition.png", 
       plot = p, width = 10, height = 6, dpi = 300, bg = "white")
    </code></pre>
</div>

<div class="explanation">
    <h4>3.1.3.2. Automated Bar Chart Generation for Multiple Metadata Variables</h4>
    <ul>
        <li>
            This approach extends the visualization to multiple metadata variables (such as "source_name_ch1" (<a href="#figure-3-1-3-1" onclick="highlightFigure('3-1-3-1')">Figure 3.1.3.1</a>), "characteristics_ch1.2" (<a href="#figure-3-1-3-2-a" onclick="highlightFigure('3-1-3-2-a')">Figure 3.1.3.2 a</a>), "characteristics_ch1.3" (<a href="#figure-3-1-3-2-b" onclick="highlightFigure('3-1-3-2-b')">Figure 3.1.3.2 b</a>), "patient id:ch1" (<a href="#figure-3-1-3-2-c" onclick="highlightFigure('3-1-3-2-c')">Figure 3.1.3.2 c</a>)), allowing for the exploration of different aspects of the dataset. It automates the creation of bar charts, making it easy to visualize sample distributions across various metadata fields. <strong>(Step 1)</strong>: The <strong><a href="https://ggplot2.tidyverse.org/" target="_blank">ggplot2</a></strong> library is loaded for plotting and <strong>viridis</strong> library for using a color palette that supports many unique colors. <strong>(Step 2)</strong>: A list of columns to visualize is defined. <strong>(Step 3)</strong>: The code loops through each column, converting column names into symbols using <strong>sym()</strong> and sanitizing the names with <strong>gsub()</strong> for valid file naming. <strong>(Step 4)</strong>: The plots are created using <strong>ggplot()</strong>, styled with <strong>theme_minimal()</strong>, and colored using <strong>scale_fill_viridis_d(option = "C")</strong>. We used <strong>scale_fill_viridis_d(option = "C")</strong> instead of <strong>scale_fill_brewer()</strong> because <strong>scale_fill_brewer()</strong> has a limited number of distinct colors to handle all categories, whereas <strong>scale_fill_viridis_d()</strong> provides more colors and ensures better contrast, making it suitable for larger datasets. Each plot is displayed and saved to a file using <strong>ggsave()</strong>.
        </li>
    </ul>
</div>

<!-- Caption for the code block -->
<p class="code-caption">Code Block 3.1.3.2. Visualizing Sample Distribution for Multiple Metadata Variables Using Automated Bar Charts</p>

<div class="code-block">
    <pre><code class="language-r">
# =========================== Step 1: Install and Load Necessary Packages =========================== #
# Load the required packages for plotting
library(ggplot2)  # For creating the bar plots
library(viridis)  # For using a color palette that supports many unique colors

# =========================== Step 2: Define Columns to Visualize =========================== #
# List of columns to visualize (these correspond to the metadata columns you want to plot)
columns_to_plot <- c("source_name_ch1", "characteristics_ch1.2", "characteristics_ch1.3", "patient id:ch1")

# =========================== Step 3: Loop Through Each Column and Create Plots =========================== #
# Loop through each column and create a bar plot for sample distribution
for (col in columns_to_plot) {
  
  # --------------------- Convert Column Name for Tidy Evaluation --------------------- #
  # Convert the column name (a string) to a symbol that ggplot can interpret within aes()
  col_sym <- sym(col)
  
  # --------------------- Sanitize Column Name for Saving Files --------------------- #
  # Replace ":" with "_" to create a valid filename (since ":" is not allowed in filenames)
  sanitized_col <- gsub("[:]", "_", col)
  
  # =========================== Step 4: Create Bar Plot =========================== #
  # Create the bar plot for the current column
  p <- ggplot(metadata, aes(x = !!col_sym, fill = !!col_sym)) +  # Fill colors based on the column
    geom_bar() +  # Create the bar chart
    geom_text(stat = "count", aes(label = ..count..), vjust = -0.5, size = 3) +  # Add text labels above bars to show the count
    theme_minimal() +  # Use a minimal theme for a clean appearance
    labs(title = paste("Sample Distribution by", col), x = col, y = "Number of Samples") +  # Add title and axis labels
    theme(axis.text.x = element_text(angle = 60, vjust = 0.5, hjust = 0.6, size = 8)) +  # Rotate x-axis labels and adjust their size
    scale_fill_viridis_d(option = "C")  # Use the "viridis" color palette to ensure enough distinct colors for each category
  
  # --------------------- Display the Plot --------------------- #
  # Print the plot so it displays in the R console or notebook
  print(p)
  
  # =========================== Step 5: Save the Plot as PNG =========================== #
  # Save the plot to a file in the specified directory with a relevant name
  ggsave(filename = paste0("Figures/3.1.3.2.Bar_Chart_Metadata_Variables/Figure3.1.3.2_", sanitized_col, "_Sample_Distribution.png"),
         plot = p, width = 10, height = 6, dpi = 300, bg = "white")
}

    </code></pre>
</div>

<!-- =================== START OF Figures (3.1.3.1. / 3.1.3.2. a/b/c) =========================== -->

		<!-- Figures Row with Click-to-Enlarge Feature -->
		<div style="display: flex; justify-content: space-around;">
		    
		    <!-- First Figure: 3.1.3.1 -->
		    <figure id="figure-3-1-3-1" style="text-align: justify; margin: 10px;">
		        <a href="Pictures/RNA_Seq_Task1/1_Figure3.1.3.1_source_name_ch1_Sample_Distribution.png" target="_blank">
		            <img src="Pictures/RNA_Seq_Task1/1_Figure3.1.3.1_source_name_ch1_Sample_Distribution.png" 
		                 alt="Sample Distribution by source_name_ch1" 
		                 style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; 
		                        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
		        </a>
		        <figcaption id="figure-caption-3-1-3-1">
		            <strong>Figure 3.1.3.1.</strong> Sample Distribution by <strong>source_name_ch1</strong>.
		        </figcaption>
		    </figure>
		
		    <!-- Second Figure: 3.1.3.2 a -->
		    <figure id="figure-3-1-3-2-a" style="text-align: justify; margin: 10px;">
		        <a href="Pictures/RNA_Seq_Task1/2_Figure3.1.3.2_characteristics_ch1.2_Sample_Distribution.png" target="_blank">
		            <img src="Pictures/RNA_Seq_Task1/2_Figure3.1.3.2_characteristics_ch1.2_Sample_Distribution.png" 
		                 alt="Sample Distribution by characteristics_ch1.2" 
		                 style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; 
		                        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
		        </a>
		        <figcaption id="figure-caption-3-1-3-2-a">
		            <strong>Figure 3.1.3.2 a.</strong> Sample Distribution by <strong>characteristics_ch1.2</strong>.
		        </figcaption>
		    </figure>
		
		    <!-- Third Figure: 3.1.3.2 b -->
		    <figure id="figure-3-1-3-2-b" style="text-align: justify; margin: 10px;">
		        <a href="Pictures/RNA_Seq_Task1/3_Figure3.1.3.2_characteristics_ch1.3_Sample_Distribution.png" target="_blank">
		            <img src="Pictures/RNA_Seq_Task1/3_Figure3.1.3.2_characteristics_ch1.3_Sample_Distribution.png" 
		                 alt="Sample Distribution by characteristics_ch1.3" 
		                 style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; 
		                        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
		        </a>
		        <figcaption id="figure-caption-3-1-3-2-b">
		            <strong>Figure 3.1.3.2 b.</strong> Sample Distribution by <strong>characteristics_ch1.3</strong>.
		        </figcaption>
		    </figure>
		
		    <!-- Fourth Figure: 3.1.3.2 c -->
		    <figure id="figure-3-1-3-2-c" style="text-align: justify; margin: 10px;">
		        <a href="Pictures/RNA_Seq_Task1/4_Figure3.1.3.2_patient id_ch1_Sample_Distribution.png" target="_blank">
		            <img src="Pictures/RNA_Seq_Task1/4_Figure3.1.3.2_patient id_ch1_Sample_Distribution.png" 
		                 alt="Sample Distribution by patient id:ch1" 
		                 style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; 
		                        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
		        </a>
		        <figcaption id="figure-caption-3-1-3-2-c">
		            <strong>Figure 3.1.3.2 c.</strong> Sample Distribution by <strong>patient id:ch1</strong>.
		        </figcaption>
		    </figure>
		
		</div>






<!-- =================== END OF Figures (3.1.3.1. / 3.1.3.2. a/b/c) =========================== -->

	  
<!-- =================== 3.2.  explanation =========================== -->
	<div class="explanation">
	    <h3> 3.2. Count Matrix: Exploration and Visualization </h3>
		<h4 style="margin-top: 5px;">3.2.1. Count Matrix Overview (Inspecting the Count Matrix using View())</h4>

	    <ul>
	        <li>
	         We examine the <strong>count matrix</strong>, which contains raw gene expression counts for each sample. This step helps us understand the structure of the data, including whether it is normalized or not, and allows us to check the <strong>column names</strong> (samples) and <strong>row names</strong> (<strong><a href="https://www.ebi.ac.uk/training/online/courses/ensembl-browsing-genomes/navigating-ensembl/investigating-a-gene/#:~:text=Ensembl%20gene%20IDs%20begin%20with,of%20species%20other%20than%20human." target="_blank">Ensembl Gene Identifiers</a></strong>) to ensure the data is formatted correctly for the next steps of differential expression analysis (Code Block 3.2.1; <a href="#figure-3-2-1" onclick="highlightFigure('3-2-1')">Figure 3.2.1</a>).
	        </li>
		    
	    </ul>
	</div>



<!-- ========== 3.2.1. Caption for the code block ============== -->
<p class="code-caption">Code Block 3.2.1. Viewing the count matrix to inspect the gene expression data for each sample.</p>
		
<!-- ======= 3.2.1. code chunk =========== -->
        <div class="code-block">
	    <pre><code class="language-r">
	# View the first few rows of the count matrix
	# This allows us to inspect the raw gene expression data for each sample.
	View(counts_matrix)
	    </code></pre>
	</div>

<!-- ============================== 3.2. Image ====================== -->
	 <figure id="figure-3-2-1" style="text-align: justify;">
	    <!-- Add a clickable link to enlarge the image -->
	    <a href="Pictures/RNA_Seq_Task1/Counts_Matrix_GSE157194.png" target="_blank">
	        <img src="Pictures/RNA_Seq_Task1/Counts_Matrix_GSE157194.png" alt="Cumulative Variance Plot" style="display: block; background-color: #f0f0f0; padding: 20px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 90%; height: 400px;">
	    </a>
	    <figcaption id="figure-caption-3-2-1">
	        Figure 3.2.1. Preview of Raw Gene Expression Count Matrix for more Inspection (After filtering out sample outliers, & Low-Count Genes).
	    </figcaption>
	</figure>

<!-- =========================  start of 3.2.2. ======================================= --> 
<!-- ================================================================================== --> 
	<div class="explanation">
	     <h3 style="margin-bottom: 0;">3.2.2. Boxplot of Raw Counts</h3>
	    <ul>
	        <li>
	            In <strong>RNA-seq analysis</strong>, <strong>boxplots of raw counts</strong> provide a crucial view of the 
	            <strong>distribution of gene expression across samples</strong>. By <strong>plotting the log-transformed counts</strong>, 
	            we can <strong>detect outliers</strong>, assess <strong>sequencing depth variations</strong>, and verify whether the data 
	            is ready for <strong>downstream analysis</strong>. <strong>Boxplots</strong> help identify potential issues, such as 
	            <strong>batch effects</strong> or <strong>technical biases</strong>, that may affect the accuracy of 
	            <strong>differential expression analysis (DEA)</strong> and the identification of <strong>biomarkers</strong>.
	        </li>
	    </ul>
	
	    <h4 style="margin-bottom: 0;">3.2.2.1. Boxplot of Raw Counts (Uncolored)</h4>
	    <ul>
	        <li>
	            This simple boxplot <a href="#figure-3-2-2-1" onclick="highlightFigure('3-2-2-1')">Figure 3.2.2.1</a> (after the removal of <strong>low-count genes</strong> and <strong>outlier samples</strong>) provides an overview of the <strong>log2-transformed gene expression counts</strong> across all samples without any group-based color distinction. It allows us to quickly assess the range of counts for each sample and identify potential <strong>outliers</strong>. This uncolored version gives a broad view of <strong>data distribution</strong> and helps to highlight <strong>sample-level variations</strong> after the removal of <strong>low-count genes</strong> and <strong>outlier samples</strong>, ensuring the data is cleaned and ready for downstream analyses.
	        </li>
	    </ul>
	
	    <ul>
	        <li>
	            In this code (Code Block 3.2.2.1), we create a boxplot for the <strong>log2-transformed counts</strong> of the count matrix. (Step 1): We load the <strong>ggplot2</strong> library to generate the plot. (Step 2): The count matrix is <strong>log2-transformed</strong> and converted into a long format for visualization. (Step 3): A basic boxplot is created with minimal styling using <strong>geom_boxplot()</strong> to show the count distribution across samples. (Step 4): The plot is saved to a specific location using the <strong>ggsave()</strong> function.
	        </li>
	    </ul>
	</div>
	
<!-- ========== 3.2.2.1. Caption for the code block ============== -->
<p class="code-caption">Code Block 3.2.2.1. Boxplot of Raw Counts (Uncolored)</p>
	  
<!-- Code Block 3.2.2.1. Boxplot of Raw Counts (Uncolored) -->
<pre><code class="language-r">
# ============================
# Step 1: Load necessary library
# ============================
library(ggplot2)

# ============================
# Step 2: Prepare Data for Plotting
# ============================
# Convert counts_matrix to a data frame and log-transform it
df <- as.data.frame(log2(counts_matrix + 1))  # Log2 transform the counts matrix

# Add a sample column (rownames will become a new column for plotting)
df$Sample <- rownames(df)

# Reshape the data for ggplot2 (long format)
df_long <- reshape2::melt(df, id.vars = "Sample")

# ============================
# Step 3: Create Boxplot
# ============================
p <- ggplot(df_long, aes(x = variable, y = value)) +
  geom_boxplot() +  # Create boxplot
  theme_minimal() +  # Apply a minimal theme for better readability
  labs(title = "Log2 Raw Counts Across Samples", x = "Samples", y = "Log2 Counts") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4),
        plot.background = element_rect(fill = "white", colour = NA),  # Set white background
        panel.background = element_rect(fill = "white", colour = NA))  # Set white background for the panel

# ============================
# Step 4: Save the Plot 3.2.2.1.Uncolored_Boxplot_Raw_Counts
# ============================
ggsave("Figures/3.2.2.Boxplot_Raw_Counts/3.2.2.1.Uncolored_Boxplot_Raw_Counts.png"", 
       plot = p, width = 13, height = 4)
</code></pre>

<!-- ==============================(Figure 3.2.2.1)================================== --> 

<figure id="figure-3-2-2-1" style="text-align: justify;">
    <!-- Add a clickable link to enlarge the image -->
    <a href="Pictures/RNA_Seq_Task1/3.2.2.1.Uncolored_Boxplot_Raw_Counts_After_Removing_LowCountGenes_AND_Outlier_Samples.png" target="_blank">
        <img src="Pictures/RNA_Seq_Task1/3.2.2.1.Uncolored_Boxplot_Raw_Counts_After_Removing_LowCountGenes_AND_Outlier_Samples.png" alt="Boxplot of Raw Counts (Uncolored)" style="display: block; background-color: #f0f0f0; padding: 20px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 400px;">
    </a>
    <figcaption id="figure-caption-3-2-2-1">
        <strong>Figure 3.2.2.1</strong>. Boxplot of log2-transformed gene expression counts across all samples, after removing low-count genes and outlier samples. This uncolored boxplot provides an overview of the distribution of gene counts across samples, helping to identify potential outliers and ensuring consistency in sequencing depth.
    </figcaption>
</figure>

<!-- =========================  start of 3.2.2.2 ======================================= --> 
<div class="explanation">
    <h4 style="margin-bottom: 0;">3.2.2.2. Boxplot of Raw Counts Colored by Experimental Condition</h4>
    <ul>
        <li>
            This enhanced version of the boxplot introduces <strong>color coding</strong> based on <strong>experimental conditions</strong>. By grouping the samples according to metadata (e.g., different treatments), we can more easily visualize how the distribution of counts changes across different conditions. This plot is particularly useful for identifying <strong>condition-specific biases</strong> or <strong>batch effects</strong> that could affect downstream analyses, such as <strong>DEA for biomarker discovery</strong>. <a href="#figure-3-2-2-2-a" onclick="highlightFigure('3-2-2-2-a')">Figure 3.2.2.2 a</a> & <a href="#figure-3-2-2-2-b" onclick="highlightFigure('3-2-2-2-b')">Figure 3.2.2.2 b</a> show the distribution of raw counts before and after removing low-count genes and outlier samples, respectively, allowing us to assess how preprocessing affects the consistency of counts across experimental conditions.
        </li>
    </ul>

    <ul>
        <li>
            In this code (Code Block 3.2.2.2), we create a boxplot colored by <strong>experimental condition</strong>. (Step 1): The <strong>metadata</strong> and <strong>count matrix</strong> are aligned based on sample IDs. (Step 2): The <strong>log2-transformed count matrix</strong> is prepared for plotting and merged with metadata information. (Step 3): A <strong>boxplot</strong> is created with colors representing the experimental conditions using <strong>geom_boxplot()</strong> and a <strong>color palette</strong>. (Step 4): The total sample count is added to the legend, and (Step 5): The final plot is saved to the desired directory using the <strong>ggsave()</strong> function.
        </li>
    </ul>

    <!-- ========== 3.2.2.2. Caption for the code block ============== -->
    <p class="code-caption"><strong>Code Block 3.2.2.2. Boxplot of Raw Counts Colored by Experimental Condition</strong></p>
    <pre><code class="language-r">
# ============================
# Load necessary libraries
# ============================
library(ggplot2)
library(reshape2)

# ============================
# Step 1: Align Sample IDs and Metadata
# ============================

# Set the row names of metadata to the sample names (stored in metadata$title)
rownames(metadata) <- metadata$title

# Extract the sample IDs from counts_matrix (columns represent samples)
sample_ids <- colnames(counts_matrix)

# Filter metadata to contain only rows that match the sample IDs in the count matrix
metadata_filtered <- metadata[metadata$title %in% sample_ids, ]

# Reorder metadata to match the order of sample IDs in the count matrix
metadata_filtered <- metadata_filtered[match(sample_ids, rownames(metadata_filtered)), ]


# ============================
# Step 2: Prepare Data for Plotting
# ============================

# Transpose the counts matrix to make samples the rows
counts_matrix_t <- t(counts_matrix)

# Convert the transposed counts matrix to a data frame and log-transform the counts
# Add 1 to avoid log(0), which is undefined
df <- as.data.frame(log2(counts_matrix_t + 1))

# Add a sample column (rownames will become a new column for plotting)
df$Sample <- rownames(df)

# Add the group information from metadata (e.g., source_name_ch1)
df$group <- metadata_filtered$source_name_ch1[match(df$Sample, rownames(metadata_filtered))]

# Ensure `group` is a factor for proper grouping in the plot
df$group <- as.factor(df$group)


# ============================
# Step 3: Reshape the Data for ggplot2 (Long Format)
# ============================

# Melt the data frame to create a long format for ggplot2
df_long <- melt(df, id.vars = c("Sample", "group"))


# ============================
# Step 4: Define Colors for Each Unique Group and Add Sample Counts to the Labels
# ============================

# Calculate the number of samples for each group
group_counts <- table(df$group)

# Calculate the total number of samples
total_samples <- sum(group_counts)

# Create the color palette for the unique groups
unique_groups <- unique(df$group)
color_palette <- c("#FF6347", "#4682B4", "#32CD32", "#FFD700", "#8A2BE2", "#00CED1")

# Ensure the color palette has enough colors for all groups
group_colors <- setNames(color_palette[1:length(unique_groups)], unique_groups)

# ============================
# Step 5: Create the Plot with Updated Group Labels
# ============================

p <- ggplot(df_long, aes(x = factor(Sample, levels = sample_ids), y = value, fill = group)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Log2 Raw Counts Across Samples by Source Name", x = "Samples", y = "Log2 Counts", 
       fill = paste0("group (Total n=", total_samples, ")")) +  # Add total number to the legend title
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 4), # Rotate and adjust x-axis labels
        plot.background = element_rect(fill = "white", colour = NA),  # Set white background
        panel.background = element_rect(fill = "white", colour = NA)) + # Set white background for the panel
  scale_fill_manual(values = group_colors, labels = paste0(levels(df$group), " (n=", group_counts[levels(df$group)], ")"))  # Use the custom color vector and add counts in the legend

# ============================
# Step 6: Save the Plot
# ============================

ggsave("Figures/3.2.2.Boxplot_Raw_Counts/3.2.2.2.Colored_Boxplot_Raw_Counts.png", 
       plot = p, width = 20, height = 6)

    </code></pre>

<!-- Boxplots Row with Click-to-Enlarge Feature -->
<div style="display: flex; justify-content: space-around;">
    
    <!-- Boxplot Figure 3.2.2.2 a (Before Removing Low-Count Genes and Outlier Samples) -->
    <figure id="figure-3-2-2-2-a" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/3.2.2.2.a_Colored_Boxplot_Raw_Counts_Before_Removing_LowCountGenes_AND_Outlier_Samples.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/3.2.2.2.a_Colored_Boxplot_Raw_Counts_Before_Removing_LowCountGenes_AND_Outlier_Samples.png" 
                 alt="Boxplot Before Removing Low-Count Genes and Outliers" 
                 style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; 
                        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-2-2-a" style="font-size: 0.9em;">
            <strong>Figure 3.2.2.2 a.</strong> Boxplot of Log2 Raw Counts across Samples Colored by Experimental Condition, before removing low-count genes and outlier samples. This figure displays the distribution of raw counts across all experimental conditions, highlighting potential outliers and inconsistencies.
        </figcaption>
    </figure>

    <!-- Boxplot Figure 3.2.2.2 b (After Removing Low-Count Genes and Outlier Samples) -->
    <figure id="figure-3-2-2-2-b" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/3.2.2.2.b_Colored_Boxplot_Raw_Counts_After_Removing_LowCountGenes_AND_Outlier_Samples.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/3.2.2.2.b_Colored_Boxplot_Raw_Counts_After_Removing_LowCountGenes_AND_Outlier_Samples.png" 
                 alt="Boxplot After Removing Low-Count Genes and Outliers" 
                 style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; 
                        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-2-2-b" style="font-size: 0.9em;">
            <strong>Figure 3.2.2.2 b.</strong> Boxplot of Log2 Raw Counts across Samples Colored by Experimental Condition, after removing low-count genes and outlier samples. This figure demonstrates how filtering out low-count genes and outliers improves the consistency of count distributions across conditions.
        </figcaption>
    </figure>

</div>



<ul>
    <li><strong>Interpretation:</strong> In <a href="#figure-3-2-2-2-a" onclick="highlightFigure('3-2-2-2-a')">Figure 3.2.2.2 a</a>, before removing low-count genes and outlier samples, the log2-transformed raw counts display a broad range of variability. There are several extreme outliers (black dots) far above the whiskers of the boxplots, indicating that some samples have unusually high counts. This suggests the presence of technical or biological variability that could skew downstream analysis. The boxplots themselves are wider and less consistent across different groups, reflecting the noise introduced by these low-count genes and outliers.</li>
    <li>After filtering, in <a href="#figure-3-2-2-2-b" onclick="highlightFigure('3-2-2-2-b')">Figure 3.2.2.2 b</a>, the data shows a much tighter distribution. While there are still outliers (black dots), these are less extreme, and they appear closer to the whiskers, representing smaller deviations from the group median. The overall range of counts has become more consistent across groups, with fewer extreme variations, allowing for a clearer comparison between the experimental conditions. This filtering process has effectively removed noise from the data, enhancing its quality and reliability for subsequent analysis by reducing the impact of low-count genes and extreme outliers.</li>
</ul>

	
<!-- =========================  End of 3.2.2.2======================================= --> 





	
	
<!-- =========================  start of  of 3.2.3======================================= --> 
<h4 style="margin-bottom: 0;">3.2.3. Histogram of Total Gene Counts Per Sample</h4>
<ul>
    <li>
        The histogram of total gene counts per sample is essential for assessing the overall sequencing depth and library size across samples in RNA-seq data. By visualizing the distribution of total gene counts (log-transformed), we can identify under-sequenced or over-sequenced samples that may need further normalization or removal during preprocessing. This visualization helps to ensure that sequencing depth is consistent across samples before differential expression analysis (DEA) and biomarker discovery. <a href="#figure-3-2-3-a" onclick="highlightFigure('3-2-3-a')">Figure 3.2.3 a</a> & <a href="#figure-3-2-3-b" onclick="highlightFigure('3-2-3-b')">Figure 3.2.3 b</a> display the distribution of gene counts before and after removing low-count genes and outlier samples, respectively, which helps to assess the impact of filtering on sequencing depth.
    </li>
</ul>

<ul>
    <li>
        In this code (Code Block 3.2.3), we create a histogram that visualizes the distribution of log10-transformed gene counts per sample. (Step 1): We define the output file path and specify where to save the generated plot. (Step 2): The PNG device is opened to capture the plot. (Step 3): We calculate the log10-transformed gene counts and create a histogram using the <code>hist()</code> function. (Step 4): To enhance the visualization, the gene count values are added as labels above each bar. Finally, (Step 5): The PNG device is closed, and the plot is saved.
    </li>
</ul>

<p class="code-caption">Code Block 3.2.3. Histogram of Total Gene Counts Per Sample</p>

<pre><code class="language-r">
# ============================
# Step 1: Define Output File Path
# ============================

# Define the file path where you want to save the image
output_file <- "C:/Users/Desktop/RNA_Seq_Task1/3/3_Count_Matrix_Exploration/3.2.3.a.histogram_Of_total_GeneCounts_Per_Sample_Before_Removing_LowCountGenes_AND_Outlier_Samples.png"

# ============================
# Step 2: Open PNG Device
# ============================

# Open the PNG device to save the plot
png(filename = output_file, width = 1200, height = 1000)

# ============================
# Step 3: Create Histogram of Log-Transformed Gene Counts
# ============================

# Calculate log10 of total counts per gene
log_gene_counts <- log10(rowSums(counts_matrix))

# Create the histogram and get the counts for each bin
hist_data <- hist(log_gene_counts,  
                  breaks = 50,  # Specify number of bins in the histogram
                  main = "Gene Count Distribution",  # Title of the plot
                  xlab = "Log10 Counts",  # Label for the x-axis
                  col = "steelblue")  # Add color to the bars

# Update the y-axis limit to make room for labels
ylim <- c(0, max(hist_data$counts) * 1.1)
plot(hist_data, col = "steelblue", main = "Gene Count Distribution", xlab = "Log10 Counts", ylim = ylim) # cex: to change the font size of the labels on the bars

# ============================
# Step 4: Add Numbers Above Bars
# ============================

# Add the text labels above the histogram bars
text(hist_data$mids, hist_data$counts, labels = hist_data$counts, pos = 3, cex = 1, srt = 45)

# ============================
# Step 5: Close the PNG Device
# ============================

# Close the PNG device
dev.off()
	
</code></pre>

<!-- Histograms Row with Click-to-Enlarge Feature -->
<div style="display: flex; justify-content: space-around;">
    
    <!-- Histogram Figure 3.2.3 a (Before Removing Low-Count Genes and Outlier Samples) -->
    <figure id="figure-3-2-3-a" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/3.2.3.a.histogram_Of_total_GeneCounts_Per_Sample_Before_Removing_LowCountGenes_AND_Outlier_Samples.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/3.2.3.a.histogram_Of_total_GeneCounts_Per_Sample_Before_Removing_LowCountGenes_AND_Outlier_Samples.png" alt="Histogram Before Removing Low-Count Genes and Outliers" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-3-a">
            <strong>Figure 3.2.3 a.</strong> Histogram of Total Gene Counts Per Sample before removing low-count genes and outlier samples. This figure highlights the initial distribution of total gene counts per sample, which can help identify under-sequenced samples or sequencing depth variability.
        </figcaption>
    </figure>

    <!-- Histogram Figure 3.2.3 b (After Removing Low-Count Genes and Outlier Samples) -->
    <figure id="figure-3-2-3-b" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/3.2.3.b.histogram_Of_total_GeneCounts_Per_Sample_After_Removing_LowCountGenes_AND_Outlier_Samples.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/3.2.3.b.histogram_Of_total_GeneCounts_Per_Sample_After_Removing_LowCountGenes_AND_Outlier_Samples.png" alt="Histogram After Removing Low-Count Genes and Outliers" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-3-b">
            <strong>Figure 3.2.3 b.</strong> Histogram of Total Gene Counts Per Sample after removing low-count genes and outlier samples. This figure shows the distribution after filtering, providing a cleaner dataset with more consistent sequencing depth across samples.
        </figcaption>
    </figure>

</div>

<ul>
    <li><strong>Interpretation:</strong> The histograms visualize the distribution of gene counts before and after filtering low-count genes and outlier samples. Before filtering (<a href="#figure-3-2-3-a" onclick="highlightFigure('3-2-3-a')">Figure 3.2.3 a</a>), the data exhibits a large proportion of genes with low expression levels, as shown by the sharp peak near the lower end of the Log10 scale. This suggests a significant amount of noise in the dataset, which can obscure meaningful biological signals. After filtering (<a href="#figure-3-2-3-b" onclick="highlightFigure('3-2-3-b')">Figure 3.2.3 b</a>), the distribution shifts, with the removal of low-count genes leading to a more balanced representation of moderately to highly expressed genes. The refined dataset, with fewer extreme values and noise, is now more suitable for downstream analyses, offering a clearer and more reliable view of gene expression patterns. This cleaning process enhances data quality, improving the robustness and accuracy of subsequent biological interpretations.
    </li>
</ul>

<!-- =========================  End of 3.2.3      ======================================= --> 
	




		    

<!-- =========================  start of 3.2.4.======================================= --> 

		
		<div class="explanation">
    <h4>3.2.4. Determining the Optimal Gene Count for Heatmap (Cumulative Variance Explained Plot)</h4>
    <ul>
        <li>
            <strong>Heatmaps</strong> are primarily exploratory tools to visually assess patterns in the data. The goal is to select enough genes to reveal meaningful clusters without overcomplicating the visualization. If <u>too many genes are included</u>, the heatmap can <u>become cluttered</u> and less informative. On the other hand, if <u>too few</u> are used, <u>important patterns may be missed</u>. Typically, 100 to 500 of the most variable genes are used for exploratory heatmaps in <strong>RNA-seq studies</strong>. To ensure clarity, we often start by testing heatmaps with the top 100, 200, 300, and 500 most variable genes, assessing how well they cluster and separate groups.
        </li>
        <li>
            However, a more data-driven approach can be taken by calculating the <strong>variance</strong> for all genes and selecting the number of genes that explains a specific proportion of the total variance. This method ensures that we capture the majority of variability in our data without including too many redundant or uninformative genes. By examining the curve of <strong>cumulative variance</strong>, we can choose a number of genes that explains a high proportion of variance, focusing on the point where the curve starts to flatten ((Code Block 3.2.4; <a href="#figure-3-2-4" onclick="highlightFigure('3-2-4')">Figure 3.2.4</a>) ).
        </li>
    </ul>




	<div class="explanation">
    <ul>
        <li>
            This code (Code Block 3.2.4) focuses on analyzing gene expression variability. <strong>(Step 1)</strong>: Required libraries like <code><a href="https://cran.r-project.org/web/packages/matrixStats/index.html" target="_blank">matrixStats</a></code> and <code><a href="https://ggplot2.tidyverse.org/" target="_blank">ggplot2</a></code> are loaded for variance calculations and plotting. <strong>(Step 2)</strong>: The gene expression data in <code>counts_matrix</code> is log2-transformed to reduce its dynamic range, making it easier to interpret. <strong>(Step 3)</strong>: Using the <code><a href="https://www.rdocumentation.org/packages/matrixStats/versions/0.62.0/topics/rowVars" target="_blank">rowVars()</a></code> function, the variance of each gene across all samples is calculated, identifying highly variable genes for further analysis. <strong>(Step 4)</strong>: The cumulative variance is computed by sorting these variances and calculating their cumulative sum, which helps assess how much variability is captured by the top genes. <strong>(Step 5)</strong>: Finally, a line plot is generated (<a href="#figure-3-2-4" onclick="highlightFigure('3-2-4')">Figure 3.2.4</a>) using <code><a href="https://ggplot2.tidyverse.org/" target="_blank">ggplot2</a></code> to visualize the cumulative variance explained by an increasing number of genes, aiding in the selection of the optimal number of genes for further analysis.
        </li>
    </ul>
	</div> 

		
<!-- ================================ Code 3.2.4.================================ --> 
		
	<!-- Caption for the code block -->
	<p class="code-caption">Code Block 3.2.4. Cumulative Variance Plot to Determine Optimal Gene Count for Heatmap</p>
			
    <div class="code-block">
        <pre><code class="language-r">
# =========== Step 1: Load Required Libraries =============
library(matrixStats)  # Or DelayedMatrixStats for variance calculations
library(ggplot2)      # For enhanced plotting capabilities

# =========== Step 2: Log2 Transformation =============
# Convert counts_matrix to a matrix and apply log2 transformation
# Log transformation reduces the dynamic range of the data, making it easier to interpret
counts_matrix_log <- log2(as.matrix(counts_matrix) + 1) 

# =========== Step 3: Calculate Gene Variances =============
# Use the rowVars() function to calculate the variance for each gene across samples
# Gene variance is used to identify the most variable genes for further analysis
gene_variances <- rowVars(counts_matrix_log)

# =========== Step 4: Calculate Cumulative Variance =============
# Sort the variances in descending order and calculate the cumulative sum
cum_variance <- cumsum(sort(gene_variances, decreasing = TRUE)) / sum(gene_variances)

# =========== Step 5: Plot Cumulative Variance using ggplot2 for enhanced plotting =============
# Plot the cumulative proportion of variance explained as the number of genes increases
# This plot will help visualize how many top genes are needed to explain a high proportion of variance
ggplot(data.frame(Genes = 1:length(cum_variance), CumulativeVariance = cum_variance), aes(x = Genes, y = CumulativeVariance)) +
  geom_line() +
  labs(title = "Cumulative Variance Explained by Top Genes", 
       x = "Number of Genes", 
       y = "Cumulative Proportion of Variance Explained") +
  theme_minimal()
        </code></pre>
    </div>
</div>

	<!-- ======= 3.2.4 image with caption =========== -->
	<figure id="figure-3-2-4" style="text-align: justify;">
	    <!-- Add a clickable link to enlarge the image -->
	    <a href="Pictures/RNA_Seq_Task1/optimal_gene_count_heatmap_cumulative_variance.png" target="_blank">
	        <img src="Pictures/RNA_Seq_Task1/optimal_gene_count_heatmap_cumulative_variance.png" alt="Cumulative Variance Plot" style="display: block; background-color: #f0f0f0; padding: 20px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); ; width: 65%; height: 450px;">
	    </a>
	    <figcaption id="figure-caption-3-2-4">
	        Figure 3.2.4. Cumulative Variance Plot to Determine Optimal Gene Count for Exploratory Heatmaps after Low-Count Gene Removal.
	    </figcaption>
	</figure>

<div class="explanation">
    <ul>
        <li>
            The plot above (<a href="#figure-3-2-4" onclick="highlightFigure('3-2-4')">Figure 3.2.4</a>) shows that the curve, with a strict focus, starts to flatten around 300 genes, where additional genes contribute diminishing returns in terms of explaining the total variance. This suggests that selecting approximately 300 genes for the heatmap would balance between capturing significant variability and avoiding unnecessary noise.
        </li>
        
    </ul>
</div>


		<div class="explanation">
    <h4>3.2.5. Exploratory Heatmaps for Gene Expression Data</h4>
    <ul>
        <li> 
            In this section, we present a series of <strong>heatmaps</strong> to explore and visualize the <strong>count data</strong> before proceeding with differential expression analysis (DEA) using <strong>DESeq2</strong>. These heatmaps allow us to understand "the structure and relationships within the data", helping identify patterns such as "clustering of samples", "variations across experimental conditions", or potential "batch effects".
        </li>
        <li>
            We employ two types of heatmaps for this exploratory phase: 
            <strong>"Unsupervised</strong> Gene Expression Heatmaps" and <strong>"Grouped</strong> Gene Expression Heatmaps".
        </li>
        <li> 
            <strong>1. Unsupervised Gene Expression Heatmaps</strong>: The data is clustered purely based on "gene expression patterns", without taking the predefined  "experimental conditions" into account. This provides an  unbiased "view of the data", revealing "natural groupings" and potential  "outliers".
        </li>
        <li>
            <strong>2. Grouped Gene Expression Heatmaps</strong>: These heatmaps focus on "specific groups" of interest, allowing for a "more targeted comparison between predefined conditions" (e.g., lesional vs. non-lesional samples, or treatment vs. baseline). This can provide insight into how specific groups of samples behave in relation to one another.
        </li>
        <li>
            For all heatmaps, we focus on the "top 300 most variable genes", as this strikes a balance between capturing "sufficient variation" and maintaining "clarity in the visualizations".
        </li>
    </ul>
</div>

<div class="explanation">
    <h3>Unsupervised Heatmaps</h3>
	<h4 style="margin-top: 5px;">3.2.5.1. Unsupervised Heatmap for All Samples (160 samples)</h4>
    <ul>
        <li>
            As is shown in <a href="#figure-3-2-5-1" onclick="highlightFigure('3-2-5-1')">Figure 3.2.5.1</a>, this heatmap clusters all 160 "samples" based on the expression of the top 300 most variable "genes". The counts matrix is "log-transformed", and both rows ("genes") and columns ("samples") are clustered.
        </li>
        <li>
            In this code (Code Block 3.2.5.1), we begin by loading the "<strong>matrixStats</strong> library" to work with matrix data and the "<strong>pheatmap</strong> library" for generating heatmaps. First (Step 1), the "<strong>as.matrix()</strong> function" converts the counts_matrix into a matrix format if it was originally a data frame, ensuring compatibility with downstream operations. Then (Step 2), we apply a "<strong>log2 transformation</strong>" to the matrix to "reduce the dynamic range" and "make the data more suitable for visualization". Next (Step 3), the top 300 most variable genes are selected based on row variance calculated from the log-transformed counts. Finally (Step 4), a heatmap is generated (<a href="#figure-3-2-5-1" onclick="highlightFigure('3-2-5-1')">Figure 3.2.5.1</a>) using <strong>pheatmap()</strong>, with options to cluster rows and columns, adjust axis label angles, and font size, and the output is saved as an image file.
        </li>
    </ul>
</div>

<!-- Caption for the code block -->
<p class="code-caption">Code Block 3.2.5.1. Unsupervised Heatmap for All Samples (160 samples)</p>

<div class="code-block">
    <pre><code class="language-r">
# ============ Load Required Libraries ============
# Load the required libraries for matrix operations and heatmap generation
library(matrixStats)  # Ensure matrixStats is loaded for row variance calculation
library(pheatmap)     # For generating heatmaps

# ============ Step 1: Convert counts_matrix to Matrix ============
# Convert counts_matrix to a matrix if it is currently a data frame
counts_matrix <- as.matrix(counts_matrix)  # Ensures compatibility with downstream functions

# ============ Step 2: Log2 Transformation of Counts ============
# Apply a log2 transformation to reduce the dynamic range of the count data
counts_matrix_log <- log2(counts_matrix + 1)  # Adding 1 to avoid log(0) issues

# ============ Step 3: Identify Top Variable Genes ============
# Recalculate the most variable genes based on the log-transformed counts
# We select the top 300 most variable genes using row variance
top_var_genes_log <- head(order(rowVars(counts_matrix_log), decreasing = TRUE), 300)  

# ============ Step 4: Generate Heatmap and Save ============
# Create the heatmap for all 166 samples based on the top 300 most variable genes
# Adjust clustering and visual parameters such as label angles and font sizes
pheatmap(counts_matrix_log[top_var_genes_log, ], 
         cluster_rows = TRUE, cluster_cols = TRUE, 
         show_rownames = FALSE, show_colnames = TRUE,  
         angle_col = 90,  # Rotate x-axis labels for better readability
         fontsize_col = 4,  # Reduce font size for the column labels
         filename = "Figures/3.2.5.Exploratory_Heatmaps/3.2.5.1.Unsupervised_Heatmap_160_Samples.png")  # Save the heatmap as an image
    </code></pre>
</div>


		
 	<!-- Heatmaps Row with Click-to-Enlarge Feature -->
	<div style="display: flex; justify-content: space-around;">
	    
	    <!-- Heatmap Figure 3.2.5.1. (160/unsupervised) -->
	    <figure id="figure-3-2-5-1" style="text-align: justify; margin: 10px;">
	        <a href="Pictures/RNA_Seq_Task1/9_Figure3.2.5.1_Unsupervised_Heatmap_160_Samples_300_Genes.png" target="_blank">
	            <img src="Pictures/RNA_Seq_Task1/9_Figure3.2.5.1_Unsupervised_Heatmap_160_Samples_300_Genes.png" alt="Heatmap 1" style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 85%; height: 80%;">
	        </a>
	        <figcaption id="figure-caption-3-2-5-1">Figure 3.2.5.1. Unsupervised Gene Expression Heatmaps for All Samples (160 samples) with the top 300 most variable genes (After filtering out outlier samples & Low-Count Genes).</figcaption>
	    </figure>
	
	    <!-- Figure 3.2.5.2. (109/unsupervised) -->
	    <figure id="figure-3-2-5-2" style="text-align: justify; margin: 10px;">
	        <a href="Pictures/RNA_Seq_Task1/10_Figure3.2.5.2_Unsupervised_Heatmap_109_Samples_300_Genes.png" target="_blank">
	            <img src="Pictures/RNA_Seq_Task1/10_Figure3.2.5.2_Unsupervised_Heatmap_109_Samples_300_Genes.png" alt="Heatmap 2" style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 85%; height: 80%;;">
	        </a>
	        <figcaption id="figure-caption-3-2-5-2">Figure 3.2.5.2. Unsupervised Gene Expression Heatmaps for Baseline Lesional and Non-lesional Samples (109 samples) with the top 300 most variable genes  (After filtering out outlier samples & Low-Count Genes).</figcaption>
	    </figure>
	
	</div>

<br>
<br>
		
<div class="explanation">
    <ul>
        <li>
            <strong>Interpretation:</strong> This heatmap (<a href="#figure-3-2-5-1" onclick="highlightFigure('3-2-5-1')">Figure 3.2.5.1</a>) provides an overview of how the "gene expression patterns" vary across all "samples." It shows "distinct clusters of samples" (at the top of the heatmap) based solely on their expression data (genes on the left of the heatmap), without considering any experimental conditions. This type of unsupervised clustering can reveal "natural groupings" within the data or highlight potential "outliers."
        </li>
    </ul>
</div>

		 



		<div class="explanation">
			<h4 style="margin-top: 5px;">3.2.5.2. Unsupervised Heatmap for Baseline Lesional and Non-lesional Samples (109 samples)</h4>
		  <ul>

	            <li>
		     <strong>Code Overview:</strong> This heatmap (<a href="#figure-3-2-5-2" onclick="highlightFigure('3-2-5-2')">Figure 3.2.5.2</a>) focuses on a subset of 109 samples (lesional and non-lesional) to compare expression patterns between baseline lesional and non-lesional samples.
		    </li>
			  
		    <li>
		      In this code (Code Block 3.2.5.2), we focus on comparing baseline lesional and non-lesional samples. <strong>Load Required Libraries:</strong> First, the <code><a href="https://cran.r-project.org/web/packages/matrixStats/index.html" target="_blank">matrixStats</a></code> and <code><a href="https://cran.r-project.org/web/packages/pheatmap/index.html" target="_blank">pheatmap</a></code> libraries are loaded for matrix operations and heatmap generation. <strong>(Step 1)</strong>: The metadata is subset to include only the baseline lesional (AL_m0) and non-lesional (AN_m0) samples by filtering based on <code>metadata$title</code>. These subsets are combined into one dataset for comparison. <strong>(Step 2)</strong>: The <code>counts_matrix</code> is filtered to include only the lesional and non-lesional samples based on the sample names in <code>metadata$title</code>. <strong>(Step 3)</strong>: A log2 transformation is applied to the filtered count matrix using <code>log2()</code> to reduce the dynamic range. <strong>(Step 4)</strong>: The top 300 most variable genes are identified based on variance using <code><a href="https://www.rdocumentation.org/packages/matrixStats/versions/0.62.0/topics/rowVars" target="_blank">rowVars()</a></code>. <strong>(Step 5)</strong>: A heatmap is generated (<a href="#figure-3-2-5-2" onclick="highlightFigure('3-2-5-2')">Figure 3.2.5.2</a>) using <code><a href="https://cran.r-project.org/web/packages/pheatmap/index.html" target="_blank">pheatmap</a></code>, with rows and columns clustered to visualize the relationship between samples and gene expression. Adjustments are made for label angles and font size, and the heatmap is saved as an image file.
		    </li>
		  </ul>
		</div>


<!-- Caption for the code block -->
<p class="code-caption">Code Block 3.2.5.2. Unsupervised Heatmap for Baseline Lesional and Non-lesional Samples (109 samples)</p>

<div class="code-block">
    <pre><code class="language-r">
# ============ Load Required Libraries ============
# Load the required libraries for matrix operations and heatmap generation
library(matrixStats)  # Ensure matrixStats is loaded for row variance calculation
library(pheatmap)     # For generating heatmaps

# ============ Step 1: Subset Metadata for Lesional and Non-lesional Samples ============
# Subset the metadata to include only the baseline lesional (AL_m0) and non-lesional (AN_m0) samples
lesional_samples <- metadata[grepl("AL_m0", metadata$title), ]  # Filter metadata for lesional samples
non_lesional_samples <- metadata[grepl("AN_m0", metadata$title), ]  # Filter metadata for non-lesional samples

# Combine lesional and non-lesional samples into one dataset for comparison
selected_samples <- rbind(lesional_samples, non_lesional_samples)

# ============ Step 2: Subset the Count Matrix ============
# Subset the count matrix to include only the lesional and non-lesional samples
# Assuming the sample names (columns) in counts_matrix match those in metadata$title
selected_sample_names <- selected_samples$title
counts_matrix_filtered <- counts_matrix[, selected_sample_names]  # Filter the count matrix for the selected samples

# ============ Step 3: Log2 Transformation of Filtered Counts ============
# Apply a log2 transformation to the filtered count matrix to reduce the dynamic range
counts_matrix_log <- log2(as.matrix(counts_matrix_filtered) + 1)  # Adding 1 to avoid log(0) issues

# ============ Step 4: Identify Top Variable Genes ============
# Recalculate the most variable genes based on the log-transformed counts
# Select the top 300 most variable genes
top_var_genes_log <- head(order(rowVars(counts_matrix_log), decreasing = TRUE), 300)  

# ============ Step 5: Generate Heatmap and Save ============
# Create a heatmap for the lesional and non-lesional samples based on the top 300 most variable genes
# Adjust clustering and visual parameters such as label angles and font sizes
pheatmap(counts_matrix_log[top_var_genes_log, ], 
         cluster_rows = TRUE, cluster_cols = TRUE, 
         show_rownames = FALSE, show_colnames = TRUE,  
         angle_col = 90,  # Rotate x-axis labels for better readability
         fontsize_col = 4,  # Reduce font size for the column labels
         filename = "Figures/3.2.5.Exploratory_Heatmaps/3.2.5.2.Unsupervised_Heatmap_Baseline_Samples.png")  # Save the heatmap as an image
    </code></pre>
</div>


<div class="explanation">
    <ul>
        <li>
            <strong>Interpretation:</strong> This unsupervised heatmap (see <a href="#figure-3-2-5-2" onclick="highlightFigure('3-2-5-2')">Figure 3.2.5.2</a> above) specifically examines how gene expression varies between baseline lesional and non-lesional samples. The clustering shows whether the lesional and non-lesional samples form distinct groups based on their gene expression, helping to assess the strength of separation between these two conditions.
        </li>
    </ul>
</div>



	<!-- Grouped Gene Expression Heatmaps -->
<div class="explanation">
    <h3>Grouped Heatmaps</h3>
	<h4 style="margin-top: 5px;">3.2.5.3. Grouped Heatmap for All Groups </h4>
    <ul>
        <li>This heatmap (<a href="#figure-3-2-5-3" onclick="highlightFigure('3-2-5-3')">Figure 3.2.5.3</a>) compares six different groups (<strong>baseline lesional</strong>, <strong>baseline non-lesional</strong>, <strong>cyclosporine lesional</strong>, <strong>cyclosporine non-lesional</strong>, <strong>dupilumab lesional</strong>, and <strong>dupilumab non-lesional</strong>).</li>
        
        <li><strong>Code Overview:</strong> In this code, we begin by loading the <strong>matrixStats</strong> and <strong>pheatmap</strong> libraries to handle matrix operations and generate heatmaps. First (Step 1), we apply a <strong>log2 transformation</strong> to the <strong>counts_matrix</strong> to reduce the dynamic range of the data. Next (Step 2), the <strong>sample_groups</strong> are extracted from <strong>metadata$<a href="#figure-3-1-2" onclick="highlightFigure('3-1-2')">source_name_ch1</a></strong>, representing the original group labels. We then (Step 3) define a <strong>new_labels</strong> vector, which maps the original group names (e.g., 'm0_AL') to more descriptive labels (e.g., 'Baseline Lesional').</li>
        
        <li>In Step 3.1, the <strong>selected_groups</strong> vector allows for different comparisons that provide insights into the data. For example, <strong>Lesional vs. Non-lesional</strong> comparisons (e.g., baseline (<a href="#figure-3-2-5-4" onclick="highlightFigure('3-2-5-4')">Figure 3.2.5.4</a>), cyclosporine (<a href="#figure-3-2-5-5" onclick="highlightFigure('3-2-5-5')">Figure 3.2.5.5</a>), dupilumab (<a href="#figure-3-2-5-6" onclick="highlightFigure('3-2-5-6')">Figure 3.2.5.6</a>) explore how gene expression differs between affected and unaffected skin; <strong>Therapy Comparisons</strong> (e.g., "Baseline Non-Lesional" vs. "Baseline Lesional", "Cyclosporine Lesional", and "Dupilumab Lesional") investigate how lesional samples respond to different treatments (<a href="#figure-3-2-5-7" onclick="highlightFigure('3-2-5-7')">Figure 3.2.5.7</a>); and <strong>Pre-treatment vs. Post-treatment comparisons</strong> assess cyclosporine or dupilumab effectiveness by examining gene expression changes before and after treatment (<a href="#figure-3-2-5-9" onclick="highlightFigure('3-2-5-9')">Figure 3.2.5.9</a> & <a href="#figure-3-2-5-10" onclick="highlightFigure('3-2-5-10')">Figure 3.2.5.10</a>) . These comparisons are crucial for understanding both disease pathology and treatment effects.</li>
        
        <li>Afterward (Step 4), the columns of <strong>counts_matrix_log</strong> are reordered based on the selected groups, and the column names are updated using the new descriptive labels. In (Step 5), then the <strong>top 300 most variable genes</strong> are selected based on the variance of the log-transformed counts. Finally (Step 6), a heatmap is generated with the updated column labels, and the output is saved as an image file.</li>
    </ul>
</div>

<!-- Code Block for Heatmap for All Groups -->
<p class="code-caption">Code Block 3.2.5.3. Grouped Heatmap for All Groups</p>
<div class="code-block">
    <pre><code class="language-r">
# =========== Load Required Libraries ===========
library(matrixStats)
library(pheatmap)

# =========== Step 1: Apply Log2 Transformation ===========
counts_matrix_log <- log2(as.matrix(counts_matrix) + 1)

# =========== Step 2: Extract Sample Grouping Information ===========
sample_groups <- metadata$source_name_ch1

# =========== Step 3: Define Descriptive Labels ===========
new_labels <- c(
  "m0_AN" = "Baseline Non-lesional",
  "cyclosporine_m3_AN" = "Cyclosporine Non-lesional",
  "dupilumab_m3_AN" = "Dupilumab Non-lesional",
  "m0_AL" = "Baseline Lesional",
  "cyclosporine_m3_AL" = "Cyclosporine Lesional",
  "dupilumab_m3_AL" = "Dupilumab Lesional"
)
	
# =================================================================================
# =========== Step 3.1: Select Groups for Analysis ===========
selected_groups <- c("m0_AN", "cyclosporine_m3_AN", "dupilumab_m3_AN", "m0_AL", "cyclosporine_m3_AL", "dupilumab_m3_AL")

# ===== we can replace the above selected_groups with one of the bellow  ===== 
# 1. Heatmap for all groups:
# c("m0_AN", "cyclosporine_m3_AN", "dupilumab_m3_AN", "m0_AL", "cyclosporine_m3_AL", "dupilumab_m3_AL")

# 2. (Lesional vs. Non-lesional) Compare "Baseline Lesional" with "Baseline Non-lesional": 
# c("m0_AN", "m0_AL")

# 3. (Lesional vs. Non-lesional) Compare Cyclosporine Lesional with Cyclosporine Non-lesional:
# c("cyclosporine_m3_AN", "cyclosporine_m3_AL") 

# 4. (Lesional vs. Non-lesional) Compare Dupilumab Lesional with Dupilumab Non-lesional:
# c("dupilumab_m3_AN", "dupilumab_m3_AL") 

# 5. (Therapy Comparisons) Compare Baseline Lesional, Cyclosporine Lesional, and Dupilumab Lesional (compared to Baseline Non-Lesional).
# c("m0_AN", "m0_AL", "cyclosporine_m3_AL", "dupilumab_m3_AL")  

# 6. (Therapy Comparisons) Compare Dupilumab Lesional and Cyclosporine Lesional.
# c("dupilumab_m3_AL", "cyclosporine_m3_AL")

# 7. (Pre-treatment vs. Post-treatment) Compare Baseline Lesional & Cyclosporine Lesional.
# c("m0_AL", "cyclosporine_m3_AL")

# 8. (Pre-treatment vs. Post-treatment) Compare Baseline Lesional & Dupilumab Lesional.
# c("m0_AL", "dupilumab_m3_AL")
# =================================================================================

	
# =========== Step 4: Reorder Columns Based on Group Selection ===========
desired_order <- selected_groups
reordered_columns <- match(desired_order, sample_groups)
counts_matrix_log <- counts_matrix_log[, reordered_columns]
colnames(counts_matrix_log) <- new_labels[sample_groups[reordered_columns]]

# =========== Step 5: Calculate Top Variable Genes ===========
top_var_genes_log <- head(order(rowVars(counts_matrix_log), decreasing = TRUE), 300)

# =========== Step 6: Generate the Heatmap ===========
pheatmap(counts_matrix_log[top_var_genes_log, ], 
         cluster_rows = TRUE, cluster_cols = TRUE,
         show_rownames = FALSE, show_colnames = TRUE,
         angle = 45, vjust = 0.5, hjust = 0.6,
         fontsize_col = 8, 
         filename = "Figures/3.2.5.Exploratory_Heatmaps/3.2.5.3.Grouped_Heatmap_All_Groups.png")
    </code></pre>
</div>

<!-- Interpretation for Heatmap for All Groups -->
<div class="explanation">
    <ul>
        <li><strong>Interpretation:</strong> As is shown in <a href="#figure-3-2-5-3" onclick="highlightFigure('3-2-5-3')">Figure 3.2.5.3</a>, this heatmap allows a broad comparison between all six groups. It helps assess how different treatments (cyclosporine and dupilumab) affect lesional and non-lesional samples, as well as providing insights into baseline differences between lesional and non-lesional samples.</li>
    </ul>
</div>

<!-- Further Comparisons -->
<div class="explanation">
   
    <h4 style="margin-top: 5px;">3.2.5.4. Grouped Heatmap to Compare "Baseline Lesional" with "Baseline Non-lesional" (Lesional vs. Non-lesional) </h4>
    <ul>
          <li> This heatmap (Code Block 3.2.5.4; <a href="#figure-3-2-5-4" onclick="highlightFigure('3-2-5-4')">Figure 3.2.5.4</a>) focuses on comparing "baseline lesional" and "baseline non-lesional" samples.</li>
          <li>This comparison between <strong>Baseline Lesional</strong> and <strong>Baseline Non-lesional</strong> is crucial for identifying 
    differentially expressed genes (<strong>DEGs</strong>) that distinguish <strong>diseased (lesional)</strong> skin from <strong>healthy (non-lesional)</strong> skin.</li>
	  <li>Firstly, these <strong>DEGs</strong> can serve <strong>diagnostic</strong> purposes, helping to identify <strong>biomarkers</strong> that differentiate <strong>Atopic Dermatitis (AD)</strong> from unaffected skin.</li>
	  <li>Secondly, understanding the <strong>baseline differences</strong> in gene expression allows for monitoring how treatments, such as <strong>Cyclosporine</strong> or <strong>Dupilumab</strong>, bring lesional skin back towards the <strong>non-lesional</strong> state, thereby evaluating <strong>treatment effectiveness</strong>. By comparing post-treatment samples with <strong>non-lesional baseline</strong> samples, we can assess which therapy restores gene expression closer to the <strong>non-lesional (healthy) state</strong>, which is important for evaluating the <strong>therapeutic impact</strong> and determining which treatment works best for <strong>normalizing skin condition</strong>.</li>
    </ul>
</div>

<!-- Code Block for Baseline Lesional vs. Non-lesional -->
<p class="code-caption">Code Block 3.2.5.4. Grouped Heatmap: Compare Baseline Lesional with Baseline Non-lesional</p>
<div class="code-block">
    <pre><code class="language-r">
# ============================
selected_groups <- c("m0_AN", "m0_AL")
# ============================
    </code></pre>
</div>

<!-- Further Comparisons for Cyclosporine, Dupilumab -->
<div class="explanation">
    <h4 style="margin-top: 5px;">3.2.5.5. Grouped Heatmap to Compare Cyclosporine Lesional vs. Cyclosporine Non-lesional (Lesional vs. Non-lesional) </h4>
    <ul>
        <li>This heatmap (Code Block 3.2.5.5. & <a href="#figure-3-2-5-5" onclick="highlightFigure('3-2-5-5')">Figure 3.2.5.5</a>) compares lesional and non-lesional samples treated with cyclosporine.</li>
        <li>By comparing <strong>Cyclosporine Lesional</strong> to <strong>Cyclosporine Non-lesional</strong>, we are assessing the <strong>Therapeutic Effectiveness</strong> and <strong>Monitoring Treatment Impact</strong>. The focus is on observing how the treatment affects gene expression in both lesional and non-lesional skin, looking for any therapeutic improvements or unintended side effects, which falls under <strong>Monitoring Treatment Impact</strong>.</li>
	<li><strong>Firstly</strong>, this comparison is crucial for determining whether Cyclosporine modulates gene expression in lesional skin towards a more normalized state (<strong>Therapeutic Effectiveness</strong>).</li>
	<li><strong>Secondly</strong>, it examines the effects on non-lesional skin, potentially revealing any unintended gene expression changes in unaffected tissue (<strong>Monitoring Treatment Impact</strong>).</li>
	<li><strong>Therefore</strong>, understanding these differences provides valuable insights into the treatmentâ€™s localized effectiveness and highlights ongoing gene expression disparities between treated lesional and treated non-lesional skin (<strong>Therapeutic Effectiveness</strong> and <strong>Monitoring</strong>).</li>

    </ul>
</div>

<p class="code-caption">Code Block 3.2.5.5. Grouped Heatmap: Compare Cyclosporine Lesional vs. Non-lesional</p>
<div class="code-block">
    <pre><code class="language-r">
# ============================
selected_groups <- c("cyclosporine_m3_AN", "cyclosporine_m3_AL")
# ============================
    </code></pre>
</div>

<!-- Continue with Dupilumab, Therapy Comparisons -->
<div class="explanation">
    <h4 style="margin-top: 5px;">3.2.5.6. Grouped Heatmap to Compare Dupilumab Lesional vs. Dupilumab Non-lesional (Lesional vs. Non-lesional) </h4>
    <ul>
        <li>This heatmap (Code Block 3.2.5.6 & <a href="#figure-3-2-5-6" onclick="highlightFigure('3-2-5-6')">Figure 3.2.5.6</a>) reveals how <strong>dupilumab treatment</strong> impacts gene expression across lesional and non-lesional samples.</li>
        
	<li>By comparing <strong>Dupilumab Lesional</strong> to <strong>Dupilumab Non-lesional</strong>, we are also assessing the <strong>Therapeutic Effectiveness</strong> and <strong>Monitoring Treatment Impact</strong>, similar to what was done for Cyclosporine. The focus remains on observing whether Dupilumab modulates gene expression in lesional skin towards a more normalized state and if there are any unintended changes in non-lesional skin, which highlights the treatmentâ€™s overall impact.</li>
	
	<li><strong>Firstly</strong>, this comparison is crucial for determining whether Dupilumab effectively restores the gene expression in lesional skin (Therapeutic Effectiveness).</li>
	
	<li><strong>Secondly</strong>, it reveals any unintended gene expression changes in the non-lesional skin, assessing the safety of the treatment on unaffected tissue (Monitoring Treatment Impact).</li>
	
	<li><strong>Therefore</strong>, understanding these gene expression differences offers insights into the localized therapeutic effects of Dupilumab, providing a similar perspective to the Cyclosporine comparison but focused on a different treatment (Therapeutic Effectiveness and Monitoring).</li>

    </ul>
</div>


	

<p class="code-caption">Code Block 3.2.5.6. Grouped Heatmap: Compare Dupilumab Lesional vs. Dupilumab Non-lesional</p>
<div class="code-block">
    <pre><code class="language-r">
# ============================
selected_groups <- c("dupilumab_m3_AN", "dupilumab_m3_AL")
# ============================
    </code></pre>
</div>


<!-- Heatmaps Row with Click-to-Enlarge Feature -->
<div style="display: flex; justify-content: space-around;">
    
    <!-- Heatmap Figure 3.2.5.3 (1_Heatmap_for_All_Groups) -->
    <figure id="figure-3-2-5-3" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/1_Figure3.2.5.3_Heatmap_for_All_Groups.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/1_Figure3.2.5.3_Heatmap_for_All_Groups.png" alt="Heatmap 1" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-3">
		<strong>Figure 3.2.5.3</strong> Grouped Gene Expression Heatmap across all six groups (Baseline Lesional, Baseline Non-lesional, Cyclosporine Lesional, Cyclosporine Non-lesional, Dupilumab Lesional, and Dupilumab Non-lesional).This allows for the broadest comparison of gene expression patterns across all groups  (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

    <!-- Heatmap Figure 3.2.5.4 (2_Baseline_Lesional_VS_Baseline_Non_lesional) -->
    <figure id="figure-3-2-5-4" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/2_Figure3.2.5.4_Heatmap_Baseline_Lesional_VS_Baseline_Non_lesional.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/2_Figure3.2.5.4_Heatmap_Baseline_Lesional_VS_Baseline_Non_lesional.png" alt="Heatmap 2" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-4">
		<strong>Figure 3.2.5.4.</strong> Grouped Heatmap: comparing Baseline Lesional and Baseline Non-lesional samples. This helps visualize how gene expression differs between affected and unaffected skin before any treatment is administered (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

    <!-- Heatmap Figure 3.2.5.5 (3_Cyclosporine_Lesional_VS_Cyclosporine_Non_lesional)-->
    <figure id="figure-3-2-5-5" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/3_Figure3.2.5.5_Heatmap_Cyclosporine_Lesional_VS_Cyclosporine_Non_lesional.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/3_Figure3.2.5.5_Heatmap_Cyclosporine_Lesional_VS_Cyclosporine_Non_lesional.png" alt="Heatmap 3" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-5">
		<strong>Figure 3.2.5.5.</strong> Grouped Gene Expression Heatmap comparing Cyclosporine Lesional and Cyclosporine Non-lesional samples. This focuses on how cyclosporine treatment impacts gene expression in affected vs. unaffected skin (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

    <!-- Heatmap Figure 3.2.5.6 (4_Dupilumab_Lesional_VS_Dupilumab_Non_lesional)-->
    <figure id="figure-3-2-5-6" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/4_Figure3.2.5.6_Heatmap_Dupilumab_Lesional_VS_Dupilumab_Non_lesional.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/4_Figure3.2.5.6_Heatmap_Dupilumab_Lesional_VS_Dupilumab_Non_lesional.png" alt="Heatmap 4" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-6">
		<strong>Figure 3.2.5.6.</strong> Grouped Gene Expression Heatmap comparing Dupilumab Lesional and Dupilumab Non-lesional samples. This visualizes the effect of dupilumab treatment on lesional and non-lesional samples (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

</div>


	

<!-- 5. Therapy Comparisons -->
<div class="explanation">
    <h4 style="margin-top: 5px;">3.2.5.7. Grouped Heatmap to Compare Baseline Lesional, Cyclosporine Lesional, and Dupilumab Lesional (compared to Baseline Non-Lesional ) (Therapy Comparisons) </h4>
    <ul>
        <li>This heatmap (Code Block 3.2.5.7. & <a href="#figure-3-2-5-7" onclick="highlightFigure('3-2-5-7')">Figure 3.2.5.7.</a>) compares <strong>lesional samples</strong> across three conditions: baseline, cyclosporine, and dupilumab treatment (in comparison with Baseline Non-Lesional). This comparison helps us to understand how <strong>lesional samples</strong> respond to different therapies and Which treatment, Cyclosporine or Dupilumab, is more effective in moving lesional skin towards a healthier or more normalized gene expression state, as compared to Baseline Non-Lesional?</li>
	<li>The comparison between <strong>Baseline Lesional</strong>, <strong>Cyclosporine Lesional</strong>, <strong>Dupilumab Lesional</strong>, and <strong>Baseline Non-Lesional</strong> helps assess the <strong>Therapeutic Effectiveness</strong> of two treatmentsâ€”<strong>Cyclosporine</strong> and <strong>Dupilumab</strong>â€”on lesional skin, using <strong>Baseline Non-Lesional</strong> (healthy) as a reference. This comparison provides insights into how each treatment modulates the gene expression profile in lesional skin after therapy.</li>
	
	<li>Firstly, this comparison highlights the extent to which each treatment modulates lesional skin's gene expression, showing how well <strong>Dupilumab</strong> or <strong>Cyclosporine</strong> restores the lesional skin towards a healthier or more normalized state when compared to <strong>Baseline Non-Lesional</strong> (<strong>Therapeutic Effectiveness</strong>).</li>
	
	<li>Secondly, by comparing both treatments against the <strong>Baseline Non-Lesional</strong> and <strong>Baseline Lesional</strong> states, this analysis reveals that <strong>Dupilumab</strong> appears more successful in restoring gene expression, as it shows high similarity to <strong>Baseline Non-Lesional</strong> and they cluster closely, suggesting a stronger positive effect (<strong>Therapeutic Effectiveness</strong>). In contrast, <strong>Cyclosporine</strong> shows less similarity to <strong>Baseline Non-Lesional</strong> and the least similarity to the other conditions, suggesting a less effective outcome.</li>
	
	<li>Therefore, this comparison provides a clear assessment of the relative efficacy of <strong>Cyclosporine</strong> and <strong>Dupilumab</strong>, offering critical insights into which treatment is more effective in modulating the gene expression of lesional skin back towards a healthy state (<strong>Therapeutic Effectiveness</strong>).</li>

    </ul>
</div>

<p class="code-caption">Code Block 3.2.5.7. Grouped Heatmap: Compare Baseline Non-Lesional vs. Baseline Lesional, Cyclosporine Lesional, and Dupilumab Lesional</p>
<div class="code-block">
    <pre><code class="language-r">
# ============================
selected_groups <- c("m0_AN", "m0_AL", "cyclosporine_m3_AL", "dupilumab_m3_AL") 
# ============================
    </code></pre>
</div>

<!-- Dupilumab vs Cyclosporine -->
<div class="explanation">
    <h4 style="margin-top: 5px;">3.2.5.8. Grouped Heatmap to Compare Dupilumab Lesional vs. Cyclosporine Lesional (Therapy Comparisons) </h4>
    <ul>
        <li> This heatmap (Code Block 3.2.5.8 & <a href="#figure-3-2-5-8" onclick="highlightFigure('3-2-5-8')">Figure 3.2.5.8</a>) compares <strong>lesional samples</strong> treated with <strong>dupilumab</strong> versus <strong>cyclosporine</strong>. This comparison allows you to directly assess how gene expression varies between <strong>dupilumab</strong> and <strong>cyclosporine treatments</strong> in lesional samples.</li>
        <li>The comparison between <strong>Dupilumab Lesional</strong> and <strong>Cyclosporine Lesional</strong> focuses on identifying how these two treatments differentially influence gene expression in lesional skin. This analysis allows us to observe the unique gene expression changes induced by each therapy and to identify treatment-specific patterns.</li>
        <li>By examining the differentially expressed genes (DEGs) between these two treatment groups, we can uncover distinct molecular pathways targeted by Dupilumab and Cyclosporine. This comparison is essential for understanding how each treatment modulates the biological processes in lesional skin and for identifying any therapeutic pathways that may be more prominent in one treatment compared to the other.</li>
    	<li>Although this analysis does not directly reveal which treatment restores skin to a healthier state (since it lacks a non-lesional reference), it offers valuable insights into the <strong>mechanisms of action</strong> of both therapies and how they diverge in their effects on lesional skin.</li>

    </ul>
</div>

<p class="code-caption">Code Block 3.2.5.8. Grouped Heatmap: Compare Dupilumab Lesional vs. Cyclosporine Lesional</p>
<div class="code-block">
    <pre><code class="language-r">
# ============================
selected_groups <- c("dupilumab_m3_AL", "cyclosporine_m3_AL")
# ============================
    </code></pre>
</div>

<!-- Pre-treatment vs. Post-treatment -->
<div class="explanation">
    <h4 style="margin-top: 5px;">3.2.5.9. Grouped Heatmap to Compare Baseline Lesional vs. Cyclosporine Lesional (Pre-treatment vs. Post-treatment) </h4>
    <ul>
        <li> This heatmap (Code Block 3.2.5.9 & <a href="#figure-3-2-5-9" onclick="highlightFigure('3-2-5-9')">Figure 3.2.5.9</a>) compares <strong>pre-treatment</strong> (baseline lesional) to <strong>post-treatment</strong> (cyclosporine lesional) samples.</li>
        <li>The comparison between <strong>Baseline Lesional</strong> and <strong>Cyclosporine Lesional</strong> focuses on evaluating the effect of Cyclosporine on lesional skin by observing how the treatment alters gene expression post-treatment compared to the untreated baseline state. This comparison provides insights into the <strong>Therapeutic Effectiveness</strong> of Cyclosporine in modulating the gene expression profile of lesional skin.</li>

	<li>Firstly, this comparison helps determine the extent to which Cyclosporine shifts the gene expression in lesional skin towards a modified or improved state after treatment, relative to its pre-treatment condition (Baseline Lesional).</li>
	
	<li>Secondly, the comparison highlights the specific <strong>differentially expressed genes (DEGs)</strong> that are altered post-treatment, offering insights into the molecular changes and pathways modulated by Cyclosporine therapy.</li>
	
	<li>Thus, this analysis provides valuable data on how Cyclosporine influences lesional skin, reflecting its impact on the underlying disease processes at the gene expression level and suggesting its therapeutic potential in treating the condition.</li>

    </ul>
</div>

<p class="code-caption">Code Block 3.2.5.9. Grouped Heatmap: Compare Pre-treatment vs. Post-treatment (Baseline Lesional & Cyclosporine Lesional)</p>
<div class="code-block">
    <pre><code class="language-r">
# ============================
selected_groups <- c("m0_AL", "cyclosporine_m3_AL")
# ============================
    </code></pre>
</div>


<!-- Pre-treatment vs. Post-treatment -->
<div class="explanation">
    <h4 style="margin-top: 5px;">3.2.5.10. Grouped Heatmap to Compare Baseline Lesional vs. dupilumab Lesional (Pre-treatment vs. Post-treatment) </h4>
    <ul>
         <li>This heatmap (Code Block 3.2.5.10 & <a href="#figure-3-2-5-10" onclick="highlightFigure('3-2-5-10')">Figure 3.2.5.10</a>) compares <strong>pre-treatment</strong> (baseline lesional) to <strong>post-treatment</strong> (dupilumab lesional) samples.</li>
        <li>The comparison between <strong>Baseline Lesional</strong> and <strong>Dupilumab Lesional</strong> allows us to evaluate the <strong>Therapeutic Effectiveness</strong> of Dupilumab by analyzing how the treatment alters the gene expression profile in lesional skin after therapy, compared to its pre-treatment condition.</li>

	<li>Firstly, this comparison helps determine the extent to which Dupilumab modulates the gene expression of lesional skin, moving it towards an improved state, compared to its baseline (untreated) condition.</li>
	
	<li>Secondly, by identifying <strong>differentially expressed genes (DEGs)</strong> between the pre-treatment and post-treatment states, we gain insights into the molecular pathways and biological processes that are influenced by Dupilumab, offering a deeper understanding of how the treatment affects lesional skin at the genetic level.</li>
	
	<li>Thus, this comparison provides a critical assessment of how Dupilumab impacts lesional skin, shedding light on its potential to restore a more normal gene expression profile in affected tissue.</li>

    </ul>
</div>	

	<p class="code-caption">Code Block 3.2.5.10. Grouped Heatmap: Compare Pre-treatment vs. Post-treatment (Baseline Lesional & Dupilumab Lesional)</p>
	<div class="code-block">
	    <pre><code class="language-r">
	# ============================
	selected_groups <- c("m0_AL", "dupilumab_m3_AL")
	# ============================
	    </code></pre>
	</div>



	<!-- Heatmaps Row with Click-to-Enlarge Feature -->
<div style="display: flex; justify-content: space-around;">
    
    <!-- Heatmap Figure 3.2.5.7. (5_Baseline_Lesional_AND_Cyclosporine_Lesional_AND_Dupilumab_Lesional) -->
    <figure id="figure-3-2-5-7" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/5_Figure3.2.5.7_Heatmap_Baseline_Non_Lesional_AND_Baseline_Lesional_AND_Cyclosporine_Lesional_AND_Dupilumab_Lesional.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/5_Figure3.2.5.7_Heatmap_Baseline_Non_Lesional_AND_Baseline_Lesional_AND_Cyclosporine_Lesional_AND_Dupilumab_Lesional.png" alt="Heatmap 1" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-7">
		<strong>Figure 3.2.5.7.</strong> Grouped Gene Expression Heatmap comparing Baseline Non-Lesional vs. Baseline Lesional, Cyclosporine Lesional, and Dupilumab Lesional samples. This offers a direct comparison of how gene expression changes under different treatments (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

    <!-- Heatmap Figure 3.2.5.8. (6_Dupilumab_Lesional_VS_Cyclosporine_Lesional) -->
    <figure id="figure-3-2-5-8" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/6_Figure3.2.5.8_Heatmap_Dupilumab_Lesional_VS_Cyclosporine_Lesional.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/6_Figure3.2.5.8_Heatmap_Dupilumab_Lesional_VS_Cyclosporine_Lesional.png" alt="Heatmap 2" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-8">
		<strong>Figure 3.2.5.8.</strong> Grouped Gene Expression Heatmap comparing Dupilumab Lesional and Cyclosporine Lesional samples. This allows for the direct comparison of how these two treatments affect lesional skin (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

    <!-- Heatmap Figure 3.2.5.9. (7_Baseline_Lesional_VS_Cyclosporine_Lesional) -->
    <figure id="figure-3-2-5-9" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/7_Figure3.2.5.9_Heatmap_Baseline_Lesional_VS_Cyclosporine_Lesional.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/7_Figure3.2.5.9_Heatmap_Baseline_Lesional_VS_Cyclosporine_Lesional.png" alt="Heatmap 3" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-9">
		<strong>Figure 3.2.5.9.</strong> Grouped Gene Expression Heatmap comparing pre-treatment (Baseline Lesional) vs. post-treatment (Cyclosporine Lesional) samples. This assesses how gene expression changes following cyclosporine treatment (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

    <!-- Heatmap Figure 3.2.5.10. (8_Baseline_Lesional_VS_Dupilumab_Lesional) -->
    <figure id="figure-3-2-5-10" style="text-align: justify; margin: 10px;">
        <a href="Pictures/RNA_Seq_Task1/8_Figure3.2.5.10_Heatmap_Baseline_Lesional_VS_Dupilumab_Lesional.png" target="_blank">
            <img src="Pictures/RNA_Seq_Task1/8_Figure3.2.5.10_Heatmap_Baseline_Lesional_VS_Dupilumab_Lesional.png" alt="Heatmap 4" style="display: block; background-color: #f0f0f0; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 100%; height: 300px;">
        </a>
        <figcaption id="figure-caption-3-2-5-10">
		<strong>Figure 3.2.5.10.</strong> Grouped Gene Expression Heatmap comparing pre-treatment (Baseline Lesional) vs. post-treatment (Dupilumab Lesional) samples. This highlights how gene expression changes following dupilumab treatment (After filtering out outlier samples & Low-Count Genes).
	</figcaption>
    </figure>

</div>


	
		

 <!-- ====================== the bellow should be changed============================== -->
 <!-- ================================================================ -->
 <!-- ================================================================ -->
		
		 <!-- ============== A horizontal line ================== -->
				<!-- Add a horizontal line above the introduction -->
				<hr style="border: none; border-top: 1px solid black; margin: 20px 0;">
		 <!-- =================================================== -->
        

        <!-- ============================    Bellow is section 4 I am working on ===================================== -->


		 <!-- ################################################################################### --> 

<!-- ========================================= 4  ======================================== -->
		<div class="explanation">
		    <h3>4.	Filtering and Subsetting Samples for Analysis</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR title 4.		     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 4.1.================================================ -->
		<div class="explanation">
		    <h3>4.1.	Keep Only Target Groups in Metadata</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 4.1.		     
		      </li>
		     </ul> 

			
			<h3>4.2.	Align counts_matrix With Filtered Metadata</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 4.2.		     
		      </li>
		     </ul> 



			<h3>4.3.	Create condition Factor</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 4.3.		     
		      </li>
		     </ul> 
		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 4.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 4.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### --> 


		
<!-- ========================================= 5  ======================================== -->
		<div class="explanation">
		    <h3>5.	Creating the DESeq2 Dataset Object</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR ONE 5		     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 5.1.================================================ -->
		<div class="explanation">
			
		    <h3>5.1. Preparing Metadata and Counts </h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 5.1.		     
		      </li>
		     </ul> 


			<h3>5.2. Constructing the DESeqDataSet Object</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 5.2.		     
		      </li>
		     </ul> 
			
		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 5.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 5.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### --> 



<!-- ========================================= 6  ======================================== -->
		<div class="explanation">
		    <h3>6.	Quality Control & Data Exploration (Post-DESeq2 Object Creation)</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 6.		     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 6.1.================================================ -->
		<div class="explanation">
			
		    <h3>6.1. Check library sizes</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 6.1.	     
		      </li>
		     </ul> 

			
		    <h3>6.2.  Inspect count distributions</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 6.2. 	     
		      </li>
		     </ul> 


			
		    <h3>6.3. Run PCA / clustering to spot outliers</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 6.3. 		     
		      </li>
		     </ul> 



			
		    <h3>6.4. Identify possible batch effects</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 6.4.	     
		      </li>
		     </ul> 

			
		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 6.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 6.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### --> 

        
<!-- ========================================= 7  ======================================== -->
		<div class="explanation">
		    <h3>7.	Run the DESeq2 Pipeline</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 7.	     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 7.1.================================================ -->
		<div class="explanation">

			
		    <h3>7.1. Estimating Size Factors and Dispersions</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 7.1.	     
		      </li>
		     </ul> 



		    <h3>7.2. Running DESeq Model</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 7.2.	     
		      </li>
		     </ul> 

			

			
		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 7.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 7.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### -->   
		 


<!-- ========================================= 8  ======================================== -->
		<div class="explanation">
		    <h3>8.	Perform Differential Expression Analysis</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 8	     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 3.1.================================================ -->
		<div class="explanation">

			
		    <h3>8.1. Setting Contrasts for Lesional vs. Non-lesional Skin</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 8.1.	     
		      </li>
		     </ul> 


						
		    <h3>8.2. Shrinking Log2 Fold Changes (LFC)</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 8.2	     
		      </li>
		     </ul> 


						
		    <h3>8.3. Extracting Significant DEGs Based on padj and LFC Thresholds</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 8.3.     
		      </li>
		     </ul> 


						
		    <h3>o	8.4. Exporting Full and Filtered DEG Tables</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 8.4.		     
		      </li>
		     </ul> 

			
		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 8.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 8.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### --> 



<!-- ========================================= 9  ======================================== -->
		<div class="explanation">
		    <h3>9.	Diagnostic and Exploratory Visualizations (QC-style and pattern-finding visuals)</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 9.		     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 9.1.================================================ -->
		<div class="explanation">

			
		    <h3>o	9.1. PCA Plot of Variance Stabilized Data (VST)</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 9.1.	     
		      </li>
		     </ul> 



						
		    <h3>o	9.2. Sample-to-Sample Distance Heatmap</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 9.2.		     
		      </li>
		     </ul> 

			
		    <h3>o	9.3. Volcano Plot of DEGs</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 9.3.		     
		      </li>
		     </ul> 

			
		    <h3>o	9.4. Heatmap of Top Differentially Expressed Genes</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 9.4	     
		      </li>
		     </ul> 


						
		    <h3>o	9.5. Expression density plots (top DEGs)</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 9.5.	     
		      </li>
		     </ul> 


						
		    <h3>o	9.6. Enhanced heatmap with annotations</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 9.6.		     
		      </li>
		     </ul> 



			
		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 9.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 9.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### --> 




<!-- ========================================= 10 ======================================== -->
		<div class="explanation">
		    <h3>10.	Functional Enrichment Analysis</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 10. what menthods we can have? PPI/GSEA and ORA for Gene Ontology (GO) terms and KEGG pathways.		     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 10.1.================================================ -->
		<div class="explanation">

			
		    <h3>10.1. Protein-Protein Interaction (PPI) subnetwork of top DEGs (STRING)</h3>

<ul>
  <li><strong>Differential Expression Analysi</strong>s (<strong>DEA</strong>) identifies genes (<strong>DEGs</strong>) that show significant changes in expression between different conditions, but disease biology emerges from how these gene products work together as <strong> genes rarely act in isolation</strong>. A <strong>PPI subnetwork</strong> contextualises the DEGs within a <strong>curated map of protein interactions</strong>, so we can see which parts of the <strong>cellular machinery</strong> are co-affected, which groups of proteins move together, and which specific proteins sit at <strong>influential positions</strong> in the network. This makes PPI analysis a natural bridge from <strong>statistical signal</strong> to <strong>biological mechanism</strong>.</li>

  <li>This analysis serves the project objectives in three ways. First, it clusters DEGs into <strong>communities</strong> (<strong>modules</strong>) that often correspond to pathways or processes, which we test with <strong>GO enrichment</strong> to expose themes relevant to <strong>AD pathogenesis</strong>. Second, it ranks proteins by <strong>network centrality</strong> to highlight candidates that could modulate broader parts of the system when perturbed. Third, it links <strong>expression change</strong> with <strong>network position</strong>, which is useful for prioritising <strong>biomarkers</strong> and potential <strong>therapeutic targets</strong> rather than treating all DEGs equally.</li>

  <li>We use several <strong>centrality measures</strong> because each captures a different notion of influence. 1ï¸âƒ£<strong>High degree</strong> (<strong>hubs</strong>) identifies classic hub genes, proteins that interact with many others. 2ï¸âƒ£<strong>High betweenness</strong> (<strong>bottlenecks/bridges</strong>) highlights genes that sit on many shortest paths and can control information flow between modules. 3ï¸âƒ£<strong>High closeness</strong> points to genes that can quickly reach the rest of the network, useful for broad signal propagation. 4ï¸âƒ£<strong>High eigenvector centrality</strong> marks influential genes that are connected to other influential genes. In text, it is best to reserve the term <strong>hub</strong> for <strong>high-degree nodes</strong>, and refer to others as <strong>bottleneck genes</strong> (betweenness), <strong>high-closeness genes</strong>, or <strong>high-eigenvector-centrality genes</strong>.</li>

  <li>To keep interpretation coherent, we build a <strong>high-confidence STRING subnetwork</strong> from the top DEGs, detect <strong>Louvain communities</strong>, and run <strong>GO over-representation</strong> within each community. We then compute <strong>centralities</strong> on the <strong>weighted graph</strong>, using <strong>STRING interaction scores</strong> and an <strong>inverse-weight distance</strong> for shortest-path metrics. <strong>Candidate biomarkers</strong> are prioritised where <strong>â‘  expression change</strong> is strong, <strong>â‘¡ network centrality</strong> is high in at least one metric, and <strong>â‘¢</strong> the gene sits in a <strong>module</strong> enriched for processes relevant to the disease context. <strong>Candidate drug targets</strong> are those <strong>central genes</strong> that also <strong>â‘£</strong> have <strong>druggable properties</strong> in the literature or databases, or that act as <strong>bridges between key modules</strong>.</li>

  <li>Two <strong>caveats</strong> guide interpretation. Central genes can be essential <strong>housekeeping components</strong>, so <strong>network prominence</strong> alone is not sufficient for nomination. <strong>PPI knowledgebases</strong> are incomplete and <strong>biased</strong>, so results are cross-checked with <strong>enrichment</strong>, <strong>direction of change</strong>, and the <strong>known biology</strong> of the system. With these controls, the <strong>PPI subnetwork</strong> converts a flat DEG list into <strong>structured hypotheses</strong>: modules that hint at <strong>perturbed pathways</strong>, and a short list of influential genes to carry into <strong>biomarker discovery</strong> and <strong>target assessment</strong>.</li>

  <li>The following subsections implement this plan step by step, from <strong>common setup</strong> and <strong>DEG mapping</strong> to <strong>network construction</strong>, <strong>module enrichment</strong>, and <strong>centrality-based ranking</strong>.</li>
</ul>

 <!-- ======================= ======= ============================ -->
 <!-- ======================= ======= ============================ -->


			
 <!-- ======================= ======= ============================ -->
 <!-- =================  ====== 10.1.1. ============================ -->
					    <h4>10.1.1. Common setup and configuration </h4>

			<ul>
				
				<li>
					This block prepares the <strong>PPI workflowâ€™s shared environment</strong> so everything downstream uses the same <strong>thresholds</strong>, <strong>folders</strong>, and <strong>dependencies</strong>. It loads packages for <strong>STRING queries (STRINGdb)</strong>, <strong>GO enrichment (clusterProfiler, org.Hs.eg.db)</strong>, <strong>graph construction and layouts (igraph, tidygraph, ggraph)</strong>, and <strong>plotting utilities (ggplot2, ggrepel, grid, scales)</strong>. It then defines the <strong>analysis â€œknobsâ€</strong> such as the <strong>STRING confidence cutoff</strong>, <strong>DEG filters</strong>, and <strong>how many genes to carry forward</strong>, creates a single <strong>output directory</strong>, registers filenames for tables generated later, and sets <strong>GO enrichment options</strong>. Finally, it checks that the <strong>DESeq2 objects</strong> exist. This section doesnâ€™t write results; it standardizes <strong>configuration</strong> so all later sections read and write consistently under <strong>fig_dir</strong>.
				</li>	
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.1. Common Setup & Configuration â€” Packages, parameters, paths, and input checks </p>

		<div class="code-block">
		    <pre><code class="language-r">


				 
############################################################
## STRING PPI + Modules (Louvain) + Enrichment-driven figures
##
## Context:
## Differential expression between lesional (AL) vs non-lesional (AN) skin,
## followed here by PPI construction (STRING), module detection (Louvain),
## GO-based functional panels, and centrality exports.
##
## Requirements in your R session:
## - 'res'        : DESeq2 results (rownames = ENSEMBL IDs, possibly with version)
## - 'res_shrunk' : shrinked results with 'log2FoldChange' aligned to 'res'
############################################################


# ==========================================================
# [Section 1/9] Common setup & configuration
#    Thresholds, output folder, filenames, enrichment options, input checks
# ==========================================================


# 1.1 Load packages
suppressPackageStartupMessages({          # keep console clean when loading libraries
  library(STRINGdb)                       # STRING API for mapping + interaction retrieval
  library(clusterProfiler)                # functional enrichment (e.g., GO)
  library(org.Hs.eg.db)                   # gene ID mapping for Homo sapiens
  library(igraph)                         # network construction + centralities
  library(ggraph)                         # grammar-of-graphics plotting for graphs
  library(tidygraph)                      # tidy interface around igraph
  library(ggplot2)                        # general plotting
  library(scales)                         # palettes, transformations
  library(ggrepel)                        # non-overlapping labels
  library(grid)                           # units for padding/spacing (unit())
})


# 1.2 User knobs (analysis thresholds and plotting controls)
min_score <- 700        # STRING combined_score threshold
top_k     <- 400        # top N DEGs to start with (after sorting by |LFC|)
padj_thr  <- 0.05       # adjusted p-value threshold
lfc_thr   <- 0.5        # absolute log2 fold-change threshold


# 1.3 Output location
fig_dir <- "C:/Users/Desktop/RNA_Seq_Task1/PPI"
dir.create(fig_dir, showWarnings = FALSE, recursive = TRUE)


# 1.4 Output filenames (node table, module lists, and module summaries)
out_nodes_csv  <- file.path(fig_dir, "ppi_modules_louvain_nodes.csv")
out_lists_csv  <- file.path(fig_dir, "ppi_modules_louvain_gene_lists.csv")
out_summary_csv <- file.path(fig_dir, "ppi_module_summary_full.csv")
out_summary_preview_csv <- file.path(fig_dir, "ppi_module_summary_preview.csv")


# 1.5 Enrichment figure settings
ontol             <- "BP"  # BP, MF, CC
top_terms_show    <- 10
min_genes_module  <- 5
top_n_enriched    <- 3
n_labels_per_net  <- 20


# 1.6 Input checks
# Ensure DESeq2 result objects exist in the environment
if (!exists("res") || !exists("res_shrunk")) {
  stop("Objects 'res' and 'res_shrunk' must exist in the environment.")
}

		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->




	



						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.2. ============================ -->
					    <h4>10.1.2. Select DEGs and map ENSEMBL to gene symbols    </h4>

			<ul>
				
				 <li>
                   This section selects the <strong>gene set</strong> that seeds the <strong>PPI network (STRING)</strong>. Using <strong>base R operations</strong>, it removes <strong>ENSEMBL version suffixes</strong>, collects the <strong>adjusted P values</strong> and <strong>shrunken log2 fold changes</strong>, filters by <strong>significance</strong> and <strong>effect size</strong>, ranks by <strong>absolute fold change</strong>, and trims to the <strong>top k</strong>. It then converts <strong>ENSEMBL IDs</strong> to <strong>HGNC symbols</strong> with <strong>clusterProfiler::bitr</strong> and <strong>org.Hs.eg.db</strong>, enforcing a <strong>one-to-one mapping</strong> to avoid <strong>ambiguous identifiers</strong>. The output is a clean <strong>symbol-level table (df2)</strong> that preserves the <strong>DE statistics</strong>. This table is the <strong>hand-off to STRING</strong> in the next section and defines the <strong>biological scope</strong> of the <strong>network</strong>.
				 </li>
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.2. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.2. DEG Selection & ENSEMBL â†’ SYMBOL Mapping </p>

		<div class="code-block">
		    <pre><code class="language-r">


# ==========================================================
# [Section 2/9] DEG selection & ENSEMBL â†’ SYMBOL mapping
#    Filter DEGs, rank by |LFC|, keep top_k; 1:1 map to HGNC symbols
# ==========================================================
 

# 2.1 Pick DEGs and prepare IDs
# -  - - - - - - - - 
#    Pipeline:
#      a) strip ENSEMBL version
#      b) collect padj and LFC from DESeq2 results
#      c) filter by padj and |LFC|
#      d) sort by |LFC| desc and keep top_k
# -  - - - - - - - - 

# Collect all gene rownames (ENSEMBL IDs, possibly with version suffix).
ens_all  <- rownames(res)
	
# Strip Ensembl version suffix if present (e.g., ENSG000001234.12 â†’ ENSG000001234) to match mapping keys.
ens_base <- sub("\\.\\d+$", "", ens_all)
# - - - - - - 
# The above regex  removes a trailing ".<digits>" (e.g., ".12"); otherwise no change:

#   \\.   -> literal dot
#   \\d+  -> one or more digits
#   $     -> end of string
# - - - - - - 

# Build a compact table of IDs and DE statistics that will feed the PPI steps.
stats_df <- data.frame(
  ENSEMBL = ens_base,
  padj    = res[ens_all, "padj"],
  LFC     = res_shrunk[ens_all, "log2FoldChange"],
  stringsAsFactors = FALSE
)

# Filter DEGs by combining significance (padj) and effect size (|LFC|)
stats_df <- subset(stats_df, !is.na(padj) & !is.na(LFC) & padj <= padj_thr & abs(LFC) >= lfc_thr)
if (nrow(stats_df) < 10) stop("Too few DEGs after filtering; adjust thresholds.")

# Rank by absolute effect size (|LFC|) and keep top_k to control network size/complexity.
stats_df <- stats_df[order(-abs(stats_df$LFC)), ]
stats_df <- head(stats_df, top_k)


# 2.2 Map ENSEMBL â†’ SYMBOL using org.Hs.eg.db (via clusterProfiler::bitr).
# Expect occasional one-to-many mappings; we collapse to a simple 1:1 in the next line.
map <- suppressWarnings(
  bitr(stats_df$ENSEMBL, fromType = "ENSEMBL", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
)
# Enforce one SYMBOL per ENSEMBL to keep node identifiers clean and unique.
map <- map[!duplicated(map$ENSEMBL), c("ENSEMBL","SYMBOL")]

# Merge DE stats with symbols; this table (df2) is the input to STRING mapping.
df2 <- merge(stats_df, map, by = "ENSEMBL")
if (nrow(df2) < 10) stop("Too few SYMBOLs after mapping; increase top_k or check IDs.")


		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->







						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.3. ============================ -->
					    <h4>10.1.3. Section 3: Map to STRING and fetch interactions </h4>

			<ul>


				

				<li>
					This step moves from genes to <strong>protein IDs</strong> for <strong>human (version 12)</strong> and gathers the <strong>interaction edges</strong>. Using <strong>STRINGdb$new</strong>, <strong>map</strong>, and <strong>get_interactions</strong>, symbols are mapped to <strong>STRING protein IDs</strong> and <strong>high-confidence interactions</strong> among the mapped set are retrieved at the chosen <strong>score threshold</strong>. Before <strong>graph construction</strong>, <strong>HGNC symbols</strong> are mapped to <strong>STRING protein IDs</strong> with <strong>removeUnmappedRows=TRUE</strong> (<strong>unmapped rows</strong> are dropped); when multiple <strong>symbols</strong> map to the same <strong>STRING_id</strong>, rows are ordered by <strong>padj</strong> (ascending) and duplicates are removed with <strong>!duplicated(STRING_id)</strong> so a <strong>single, most significant entry</strong> remains per <strong>protein</strong>. Edges are pruned to <strong>undirected unique pairs</strong> by building a <strong>pairwise key</strong>, ensuring each protein pair appears once. The result is an <strong>edge list</strong> with <strong>combined_score weights</strong> plus a vetted <strong>node table</strong> of <strong>mapped proteins</strong>. These two objects are the inputs for <strong>graph construction</strong> in the next section and encode both <strong>network membership</strong> and <strong>interaction strength</strong>.
				</li>
			
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.3. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.3. STRING Mapping & Interaction Retrieval â€” Map symbols to STRING IDs and fetch high-confidence edges</p>

		<div class="code-block">
		    <pre><code class="language-r">
			


# ==========================================================
# [Section 3/9] STRING mapping & interaction retrieval
#    Map symbols to STRING IDs; fetch high-confidence edges; deduplicate pairs
# ==========================================================


# 3.1 Map to STRING identifiers
# -  - - - - - - - - 
# SYMBOL -> STRING IDs and INTERACTIONS
# -  - - - - - - - - 
# Initialize STRING for human (9606), requesting only edges at or above min_score.
# This setting pre-filters returned interactions by confidence.
string_db <- STRINGdb$new(
  version = "12", species = 9606,
  score_threshold = min_score, input_directory = ""
)

# map symbols to STRING IDs; remove proteins with no mapping
mapped <- string_db$map(df2, "SYMBOL", removeUnmappedRows = TRUE)


# Set a deterministic priority for many-to-one mappings (multiple SYMBOLs â†’ same STRING_id).
# Here we prioritise the smallest padj (most significant). This only affects which duplicate is kept.
mapped <- mapped[order(mapped$padj), ]
# Keep a single row per STRING protein to avoid duplicate nodes in the graph.
# Because of the sort above, the retained row is the one with the smallest padj for that STRING_id.
mapped <- mapped[!duplicated(mapped$STRING_id), ]

	
if (nrow(mapped) < 10) stop("Too few mapped STRING IDs; adjust thresholds.")


# 3.2 Fetch high-confidence interactions among mapped proteins and deduplicate
edges <- string_db$get_interactions(mapped$STRING_id)
# Retain only the minimal columns needed downstream.
edges <- subset(
  edges,
  combined_score >= min_score &
    from %in% mapped$STRING_id &
    to   %in% mapped$STRING_id &
    from != to,
  select = c("from","to","combined_score")
)

# Build an undirected key and drop duplicates (keep one edge per pair)
key <- ifelse(edges$from < edges$to,
              paste(edges$from, edges$to),
              paste(edges$to, edges$from))

edges <- edges[!duplicated(key), ]



		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->





						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.4. ============================ -->
					    <h4>10.1.4. Build the PPI graph and keep meaningful components  </h4>

			<ul>

				<li>
				The code now assembles a <strong>weighted protein network</strong>. With <strong>igraph::graph_from_data_frame</strong>, it builds an <strong>undirected igraph</strong> whose nodes carry <strong>gene labels</strong>, <strong>log2FC</strong>, and <strong>padj</strong>, and whose edges carry <strong>STRING combined_score</strong>. <strong>igraph::simplify</strong> removes <strong>loops</strong> and <strong>multiple edges</strong> while averaging scores if needed, producing a <strong>canonical representation</strong>. Using <strong>components</strong> and <strong>induced_subgraph</strong>, it keeps only <strong>connected components</strong> with <strong>at least three nodes</strong> so small fragments do not dominate the <strong>figures</strong> or <strong>summaries</strong>. The output is a <strong>tidy igraph object (g)</strong> that captures the <strong>substantive structure</strong> used by all <strong>downstream computations</strong> and <strong>plots</strong>.	
				</li>
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.4. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.4. PPI Graph Construction & Component Filtering â€” Build igraph and retain components â‰¥ 3 nodes </p>

		<div class="code-block">
		    <pre><code class="language-r">
			


# ==========================================================
# [Section 4/9] Graph build & component filtering
#    Build igraph with attributes; simplify; keep components â‰¥ 3 nodes
# ==========================================================
 

# ==========================================================
# 4.1 BUILD IGRAPH OBJECT with attributes (nodes: proteins; edges: STRING interactions)

# Assemble a vertex (node or protein) table with the attributes weâ€™ll carry through (labels and DE stats).
verts <- unique(mapped[, c("STRING_id","SYMBOL","LFC","padj")])
# Rename STRING_id â†’ name to meet igraph expectations.
colnames(verts)[1] <- "name"

# Build an undirected igraph from edges and vertices; 
# Attach gene label, LFC, and padj as node attributes
g <- graph_from_data_frame(
  d = edges, directed = FALSE,
  vertices = data.frame(
    name  = verts$name,
    label = verts$SYMBOL,
    lfc   = verts$LFC,
    padj  = verts$padj
  )
)


# 4.2  Simplify graph to remove multiedges and loops (average score if needed)
g <- simplify(
  g,
  remove.multiple = TRUE,
  remove.loops = TRUE,
  edge.attr.comb = list(combined_score = "mean", "ignore")
)


# 4.3  Identify connected components and keep meaningful components (â‰¥ 3 nodes)
comp <- components(g)
keep <- which(comp$csize[comp$membership] >= 3)
g <- induced_subgraph(g, vids = keep)
if (vcount(g) == 0) stop("No components >= 3 nodes; lower score or increase top_k.")





		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->





						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.5. ============================ -->
					    <h4>10.1.5. Section 5: Detect basic node metrics and Louvain modules and assemble tidy tables (CSV exports)  </h4>

			<ul>
				
				<li>
					With the graph in place, this section computes simple <strong>per-node metrics</strong> (<strong>degree</strong> and <strong>up/down sign</strong> from <strong>LFC</strong>) and assigns <strong>community labels</strong>. It calculates <strong>degree</strong> and encodes regulation direction (up/down) from <strong>log2FC</strong>, then runs <strong>Louvain community detection (cluster_louvain)</strong> using the <strong>STRING scores</strong> as weights to define data-driven <strong>modules</strong>. From these assignments it creates two <strong>exportable tables</strong>: a <strong>per-node table (out_nodes_csv)</strong> that includes <strong>STRING ID</strong>, <strong>gene symbol</strong>, <strong>module</strong>, <strong>degree</strong>, <strong>log2FC</strong>, and <strong>padj</strong>; and a long table of <strong>module â†’ gene map (out_lists_csv)</strong>. and two flavors of <strong>module summaries (full and preview)</strong>. It also draws a compact <strong>bar plot of module sizes</strong> so readers get a quick sense of <strong>network structure</strong> at a glance.
				</li>
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.5. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.5. Node Metrics & Louvain Modules â€” Degree/sign, community detection, and CSV exports </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
# ==========================================================
# [Section 5/9] Node metrics & Louvain modules (CSV exports)
#    Degree/sign; Louvain modules; node table and module list
# ==========================================================


# ==========================================================
# 5.1 NODE METRICS (degree, sign) + network stats for figure subtitle
# ==========================================================
# Compute unweighted degree per node (vertex); store as attribute for plotting and tables.
deg <- degree(g)

# ----------------------------------------------------------
# Creating two vertex attributes on g:
# 1.deg (numeric): degree of each node
# 2. sign (character): "Upregulated" or "Downregulated" from V(g)$lfc
# ----------------------------------------------------------


# Store the degree vector as a vertex attribute named "deg".
# After this, we can access it as V(g)$deg and use it for plotting/tables.
V(g)$deg  <- deg 


# Create a categorical vertex attribute "sign" from log2 fold-change (V(g)$lfc).
# Nodes with lfc >= 0 are labeled "Upregulated", others "Downregulated".
# (Assumes V(g)$lfc was set earlier when the graph was built.)
V(g)$sign <- ifelse(V(g)$lfc >= 0, "Upregulated", "Downregulated")


# ----------------------------------------------------------
# Summary counts for subtitle/context: size of largest component, total nodes, total edges.
# ----------------------------------------------------------
comp2   <- components(g) # connected-components summary: $membership, $csize (sizes), $no (count)
LCC     <- max(comp2$csize) # size of the Largest Connected Component (number of nodes in biggest component)
nodes   <- vcount(g) # total number of nodes in the current graph
edges_n <- ecount(g) # total number of edges in the current graph


# - - - - - - - 
# comp2$membership â†’ component ID for each node

# comp2$csize â†’ sizes of each component

# comp2$no â†’ total count of components
# - - - - - - -

 
# 5.2 COMMUNITY DETECTION (modules via Louvain)
# - - - - - -  - - -
#    - Assign module labels per node
#    - Build a "module -> genes" list and keep modules with >= 3 genes
#    - Prepare tidy per-node table (vdf) and save CSVs
# - - - - - -  - - -

# detect Louvain communities using STRING scores as edge weights
comm <- cluster_louvain(g, weights = E(g)$combined_score) 

# store each vertex's community ID as factor attribute "module"
V(g)$module <- factor(membership(comm))

# vector of community sizes (number of vertices in each)
sizes_comm  <- sizes(comm)


# 5.3 Exports: node table and moduleâ†’gene mapping
# ----------------------------------------------------------

# group gene symbols by their module ID
# split gene symbols (V(g)$label) into a list grouped by each vertexâ€™s module ID (V(g)$module); one element per module
modules_list <- split(V(g)$label, V(g)$module)


# keep only modules with â‰¥ 3 genes
modules_list <- modules_list[sapply(modules_list, length) >= 3]

# sort modules by size (descending)
modules_list <- modules_list[order(sapply(modules_list, length), decreasing = TRUE)]

# vector of retained module IDs
keep_mods <- names(modules_list)


# ----------------------------------------------------------
# Build a tidy node table (one row per gene) for export/inspection and downstream linking.
# ----------------------------------------------------------

vdf <- data.frame(
  STRING_id = V(g)$name,
  gene      = V(g)$label,
  module    = V(g)$module,
  deg       = V(g)$deg,
  lfc       = V(g)$lfc,
  padj      = V(g)$padj,
  stringsAsFactors = FALSE
)


# Keep only nodes in retained modules; 
vdf <- subset(vdf, module %in% keep_mods)


# sort by module then by degree to surface hubs first. 
## Save node table and module gene lists
write.csv(vdf[order(as.numeric(vdf$module), -vdf$deg), ], out_nodes_csv, row.names = FALSE)


# Long-format moduleâ†’gene map (useful for enrichment, reporting, and reproducibility).
# Save module -> gene mapping (long format)
mod_map <- do.call(rbind, lapply(names(modules_list), function(m) {
  data.frame(module = m, gene = modules_list[[m]], stringsAsFactors = FALSE)
}))

write.csv(mod_map, out_lists_csv, row.names = FALSE)


		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->





						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.6. ============================ -->
					    <h4>10.1.6. Section 6: Module summaries and size overview </h4>

			<ul>
				
				<li>
This block rolls the <strong>module membership</strong> into concise, publication-friendly summaries. Using <strong>base R aggregation</strong>, it creates a <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/ppi_module_summary_full.csv&title=Full%20module%20summary" target="_blank" rel="noopener"><strong>â€œfullâ€ CSV</strong></a> <strong>(PPI module full summary)</strong> where each module lists all genes in a single cell and a <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/ppi_module_summary_preview.csv&title=Preview%20module%20summary" target="_blank" rel="noopener"><strong>â€œpreviewâ€ CSV</strong></a> <strong>(PPI module preview summary)</strong> with the top 10 genes in each module, alongside <strong>module sizes</strong>. In addition, it outputs a <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/ppi_modules_louvain_gene_lists.csv&title=Long%20moduleâ€“gene%20list" target="_blank" rel="noopener"><strong>long moduleâ€“gene list CSV</strong></a> (one row per <code>module</code>â€“<code>gene</code> pair) and a <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/ppi_modules_louvain_nodes.csv&title=Node%20attributes%20with%20stats" target="_blank" rel="noopener"><strong>node attribute CSV</strong></a> (DEGs with <code>module</code> assignments and statistics). It then draws a compact <strong>bar chart of module sizes</strong> with <strong>ggplot2</strong> and saves it as a <strong>PNG</strong> <a href="#figure-10-1-6-1" onclick="highlightFigure('10-1-6-1')">(Figure 10.1.6.1)</a>.				</li>

			  

       		  <li>
				  This block starts from the <strong>tidy moduleâ€“gene map</strong> created earlier (<code>mod_map</code>, columns <code>module</code> and <code>gene</code>), coerces both columns to <strong>character</strong> to avoid factor issues, counts how many <strong>genes per module</strong> with <code>table()</code> and orders modules from <strong>largest to smallest</strong> (<code>mod_counts</code>), then groups genes by module with <code>split()</code>, removes <strong>duplicates</strong> with <code>unique()</code>, and collapses names into <strong>comma-separated strings</strong> in two flavors: a <strong>full list</strong> and a <strong>short preview</strong>. The <strong>full list</strong> is written as <strong>ppi_module_summary_full.csv</strong> with columns <code>module</code>, <code>n_genes</code>, <code>genes_all</code>, one row per module containing every member gene as a single string; the <strong>short version</strong> keeps only the <strong>first ten genes per module</strong> and is written as <strong>ppi_module_summary_preview.csv</strong> with columns <code>module</code>, <code>n_genes</code>, <code>example_genes</code>, which is convenient for quick scanning. For <strong>transparency</strong> and <strong>downstream work</strong> we also publish two additional tables: <strong>ppi_modules_louvain_gene_lists.csv</strong>, a <strong>long table</strong> with one row per membership (<code>module</code>, <code>gene</code>) that mirrors <code>mod_map</code> and is ideal for <strong>joins or filtering</strong>, and <strong>ppi_modules_louvain_nodes.csv</strong>, the <strong>node attribute table</strong> for every DEG that entered the PPI with columns <code>STRING_id</code>, <code>gene</code>, <code>module</code>, <code>deg</code>, <code>lfc</code>, <code>padj</code>, which supports <strong>statistics per module</strong>, <strong>ranking nodes</strong> by degree or effect size, and <strong>enrichment tests</strong>. Finally, the code draws a <strong>bar chart of module sizes</strong> with <strong>ggplot2</strong> (<code>p_sizes</code>) and saves it as <strong>ppi_module_sizes_barplot.png</strong>, so readers can see at a glance which <strong>communities are largest</strong> and then click through to the <strong>detailed CSVs</strong>.
			 
			  </li>
			
			
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.6. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.6. Module Summaries & Overview Figure â€” Full/preview CSVs and module size bar plot </p>

		<div class="code-block">
		    <pre><code class="language-r">
# ==========================================================
# [Section 6/9] Module summaries & overview figure
#    - Full/preview CSVs; module size barplot (PNG)
# ==========================================================


# 6.1 MODULE SUMMARIES
# - - - -  - - -
#     - Full list (all genes in a single cell)
#     - Preview (first 10 genes) + size bar plot
# - - - -  - - -
# Make sure types are plain character before tabulating to avoid factor pitfalls.
mod_map$module <- as.character(mod_map$module) 
mod_map$gene   <- as.character(mod_map$gene)

# Count genes per module and order modules by size (largest first).
mod_counts <- sort(table(mod_map$module), decreasing = TRUE)

# Build a â€œfullâ€ summary: one row per module with all its genes collapsed to a single string.
examples_full <- lapply(split(mod_map$gene, mod_map$module), function(x) {
  ux <- unique(x); paste(ux, collapse = ", ")
})
examples_full <- examples_full[names(mod_counts)]


module_summary_full <- data.frame(
  module        = names(mod_counts),
  n_genes       = as.integer(mod_counts),
  genes_all     = unname(unlist(examples_full)),
  stringsAsFactors = FALSE
)

write.csv(module_summary_full, out_summary_csv, row.names = FALSE)

# Build a short â€œpreviewâ€ summary: first 8 genes per module for quick scanning.
examples_preview <- lapply(split(mod_map$gene, mod_map$module), function(x) {
  ux <- unique(x); paste(ux[seq_len(min(10, length(ux)))], collapse = ", ")
})
examples_preview <- examples_preview[names(mod_counts)]
module_summary_preview <- data.frame(
  module        = names(mod_counts),
  n_genes       = as.integer(mod_counts),
  example_genes = unname(unlist(examples_preview)),
  stringsAsFactors = FALSE
)

write.csv(module_summary_preview, out_summary_preview_csv, row.names = FALSE)



# 6.2 Quick bar plot of module sizes (for overview)
library(ggplot2)

p_sizes <- ggplot(module_summary_preview,
                  aes(x = reorder(module, -n_genes), y = n_genes, fill = factor(module))) +
  geom_col(width = 0.8, color = "grey60") +
  geom_text(aes(label = n_genes), vjust = -0.35, size = 3) +
  scale_fill_viridis_d(option = "C", end = 0.95) +  # rich, non-white colors
  labs(x = "Module ID", y = "Number of genes", title = "PPI module sizes") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank(),
        plot.title = element_text(face = "bold", size = 16),
        axis.title = element_text(face = "bold")) +
  expand_limits(y = max(module_summary_preview$n_genes) * 1.12)

# saved as PNG for documentation.
ggsave(file.path(fig_dir, "ppi_module_sizes_barplot_colored.png"),
       p_sizes, width = 8, height = 4.5, dpi = 320, bg = "white")





		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->

	
<!-- ======================== (start) 10-1-6 section (Figure after code section) ============================ -->
	<!-- PPI Module Sizes Barplot -->
<div style="display: flex; justify-content: space-around;">
    
    <figure id="figure-10-1-6-1" style="text-align: justify; margin: 10px;">
        <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/Pictures/RNA_Seq_Task1/10.1.6.1.ppi_module_sizes_barplot_colored.png" target="_blank">
            <img src="https://mohammadrezamohajeri.github.io/Main_Portfolio/Pictures/RNA_Seq_Task1/10.1.6.1.ppi_module_sizes_barplot_colored.png" 
                 alt="PPI module sizes barplot" 
                 style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2); width: 85%; height: 80%;">
        </a>
        <figcaption id="figure-caption-10-1-6-1">
            Figure 10.1.6.1. Distribution of PPI module sizes, showing the number of genes per detected community. Larger modules (e.g., Module 7) contain substantially more genes, while smaller modules consist of only a few genes.
        </figcaption>
    </figure>

</div>


<!-- ========================  (end) 10-1-6 section (Figure after code section) ============================ -->




	



						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.7. ============================ -->
					    <h4>10.1.7. Section 7: Full-network visualizations  </h4>

			<ul>
				 

			    <li>
					To contextualize the network at a glance, this section renders <strong>two complementary overviews</strong> using <strong>tidygraph::as_tbl_graph</strong> and <strong>ggraph</strong> with a <strong>Fruchtermanâ€“Reingold layout</strong>. One plot colors nodes by <strong>regulation direction</strong> to highlight <strong>expression patterns</strong> across the network; the other colors by <strong>module</strong> to display <strong>community structure</strong>. In both, <strong>node size</strong> reflects <strong>degree</strong>, a fixed number of <strong>high-degree hubs</strong> are labeled with <strong>ggraph::geom_node_text</strong>, and output images are saved as <strong>high-resolution PNGs</strong>. These figures help readers see <strong>overall architecture</strong>â€”<strong>dense regions</strong>, <strong>cross-module links</strong>, and <strong>prominent hubs</strong>â€”before drilling into <strong>functional details</strong>.
				</li>



				<li> Regarding the Outputs, the first visualization (<a href="#figure-10-1-7-1" onclick="highlightFigure('10-1-7-1')">Figure 10.1.7.1</a>) shows the <strong>proteinâ€“protein interaction (PPI) subnetwork</strong> of the <strong>top differentially expressed genes (DEGs)</strong>, with <strong>nodes</strong> sized according to their <strong>connectivity (degree)</strong> and <strong>colored</strong> by <strong>regulation status</strong>. <strong>Red nodes</strong> indicate <strong>upregulated genes</strong>, while <strong>blue nodes</strong> indicate <strong>downregulated genes</strong>. The <strong>labels</strong> highlight the <strong>top 25 hub genes</strong> with the highest connectivity, providing insight into <strong>potential key drivers</strong> within the network. This plot emphasizes how <strong>highly connected upregulated genes</strong> dominate the <strong>central network structure</strong>, while <strong>downregulated genes</strong> appear less frequent and more peripheral. </li> <li> The second visualization (<a href="#figure-10-1-7-2" onclick="highlightFigure('10-1-7-2')">Figure 10.1.7.2</a>) displays the same <strong>network</strong>, but this time <strong>nodes</strong> are <strong>colored</strong> by <strong>Louvain-detected modules</strong>, which represent <strong>functionally or topologically distinct gene communities</strong>. Each <strong>color</strong> corresponds to a different <strong>module</strong>, with the <strong>legend</strong> identifying all <strong>16 modules</strong> that meet the <strong>minimum size threshold (â‰¥ 3 genes)</strong>. This view highlights <strong>modular structure</strong> within the <strong>PPI network</strong>, making it easier to identify <strong>groups of genes</strong> that may be <strong>co-regulated</strong> or share <strong>related biological functions</strong>. </li>

				<li> Regarding the code, the code begins by converting the <strong>network object (`g`)</strong> into a <strong>tidygraph format (`as_tbl_graph`)</strong> suitable for visualization with <strong>ggraph</strong>. It defines the <strong>number of hub labels (`n_labels_target = 25`)</strong> and selects the <strong>top-degree genes</strong> to reduce clutter. For the first plot, the <strong>layout</strong> is fixed with a <strong>random seed</strong> for <strong>reproducibility</strong>, and <strong>edges</strong> are drawn in <strong>faint black lines</strong>. <strong>Nodes</strong> are sized by <strong>degree</strong> and <strong>colored</strong> according to their <strong>regulation sign (`Upregulated` or `Downregulated`)</strong>, with <strong>hub labels</strong> placed using <strong>repulsion</strong> (<code>repel = TRUE</code> in <code>geom_node_text()</code> to space them apart) to avoid overlap. <strong>Titles and subtitles</strong> provide key statistics such as the <strong>number of nodes</strong>, <strong>edges</strong>, and <strong>largest connected component (LCC)</strong>. </li> 
				
				<li> For the second plot, the focus shifts to <strong>community structure</strong>. The <strong>Louvain module assignments</strong> are ensured to be <strong>factors</strong> for consistent categorical coloring. A <strong>custom color palette</strong> is generated using <strong>RColorBrewerâ€™s `"Set2"` scheme</strong>, extended with <strong>`colorRampPalette`</strong> to produce distinct <strong>colors</strong> for all <strong>modules</strong>. Each <strong>module</strong> is then assigned a <strong>unique color</strong>, and <strong>nodes</strong> are drawn with size proportional to <strong>degree</strong> and <strong>colored</strong> by <strong>module</strong>. <strong>Hub labels</strong> are again selectively displayed to maintain readability. The result is a pair of <strong>complementary visualizations</strong>: one showing <strong>regulatory status</strong> across the full <strong>PPI network</strong>, and the other revealing its <strong>modular community structure</strong>. </li>

				
				
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.7. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.7. Full-Network Visualizations â€” FR layout colored by LFC sign and by module </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
# ==========================================================
# [Section 7/9] Full-network visualizations (PNGs)
#    - FR layout, (a) colored by LFC sign, (b) colored by module
# ==========================================================

# 7.1 Plot: full network colored by LFC sign
# Convert to a tidygraph object for ggraph plotting.
tg <- as_tbl_graph(g) 
n_labels_target <- 25
# Choose which nodes to label in the plot: top-degree hubs to reduce text clutter.
label_nodes <- names(sort(deg, decreasing = TRUE))[seq_len(min(n_labels_target, length(deg)))]

edge_col <- "black"
# Main title and subtitle showing key network stats for context.
title_main <- sprintf("PPI subnetwork of top DEGs (STRING score >= %d)", min_score)
subtitle_main <- sprintf(
  "Full network (components >= 3). LCC = %d | nodes = %d | edges = %d. labels = top %d hubs.",
  LCC, nodes, edges_n, n_labels_target
)

# Fix the force-directed layout seed for reproducible node placement across runs.
set.seed(42)
p_lfc <- ggraph(tg, layout = "fr") +
  geom_edge_link0(edge_width = 0.10, edge_alpha = 0.18, lineend = "round", colour = edge_col) +
  geom_node_point(aes(size = deg, color = sign)) +
  ggraph::geom_node_text(
    aes(label = ifelse(name %in% label_nodes, label, "")),
    repel = TRUE, max.overlaps = Inf, force = 2,
    box.padding = unit(0.35, "lines"), point.padding = unit(0.30, "lines"),
    segment.size = 0.12, size = 3.0
  ) +
  coord_cartesian(clip = "off") +
  scale_size(range = c(2.2, 6.0), name = "Degree") +
  scale_color_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue"), name = "LFC sign") +
  ggtitle(title_main, subtitle = subtitle_main) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        plot.subtitle = element_text(hjust = 0.5, size = 10),
        legend.position = "right",
        plot.margin = margin(20, 60, 20, 20))

ggsave(file.path(fig_dir, "7.1.ppi_full_network_lfc.png"), p_lfc, width = 8, height = 6, dpi = 300, bg = "white")


# 7.2 Plot: full network colored by module (categorical palette per Louvain community)
# Ensure module is a factor (so colors are discrete and stable).
V(g)$module <- as.factor(V(g)$module)
module_levels <- levels(V(g)$module)


# Distinct categorical palette for modules; one color per Louvain community.
# Here we use RColorBrewer 'Set2' and extend it with colorRampPalette 
# to provide clearer separation when many modules are present.
n_mod <- length(module_levels)
pal_mod <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(n_mod)
names(pal_mod) <- module_levels

set.seed(42)
p_mod <- ggraph(tg, layout = "fr") +
  geom_edge_link0(edge_width = 0.10, edge_alpha = 0.18, lineend = "round", colour = "black") +
  geom_node_point(aes(size = deg, color = module)) +
  ggraph::geom_node_text(
    aes(label = ifelse(name %in% label_nodes, label, "")),
    repel = TRUE, max.overlaps = Inf, force = 2,
    box.padding = unit(0.35, "lines"), point.padding = unit(0.30, "lines"),
    segment.size = 0.12, size = 3.0
  ) +
  scale_size(range = c(2.2, 6.0), name = "Degree") +
  scale_color_manual(values = pal_mod, breaks = module_levels, name = "Module") +
  ggtitle(sprintf("PPI modules (Louvain). %d modules (>= 3 genes)", length(keep_mods))) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
        legend.position = "right",
        plot.margin = margin(20, 60, 20, 20))

ggsave(file.path(fig_dir, "7.2.ppi_full_network_modules.png"), p_mod, width = 8, height = 6, dpi = 300, bg = "white")

		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->



<!-- Full-network visualizations (Section 10.1.7) -->
<div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 16px;">

  <!-- Figure 10.1.7.1 â€” LFC sign -->
  <figure id="figure-10-1-7-1" style="text-align: justify; margin: 10px; flex: 1 1 520px; max-width: 820px;">
    <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/Pictures/RNA_Seq_Task1/10.1.7.1.ppi_full_network_lfc.png" target="_blank" rel="noopener">
      <img src="https://mohammadrezamohajeri.github.io/Main_Portfolio/Pictures/RNA_Seq_Task1/10.1.7.1.ppi_full_network_lfc.png"
           alt="PPI subnetwork of top DEGs colored by LFC sign with node size proportional to degree"
           style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); width: 85%; height: 80%;">
    </a>
    <figcaption id="figure-caption-10-1-7-1">
      Figure 10.1.7.1. PPI subnetwork of top DEGs colored by log-fold-change (red: upregulated; blue: downregulated);
      node size reflects degree (connectivity). Labels show the top 25 hubs.
    </figcaption>
  </figure>

  <!-- Figure 10.1.7.2 â€” Louvain modules -->
  <figure id="figure-10-1-7-2" style="text-align: justify; margin: 10px; flex: 1 1 520px; max-width: 820px;">
    <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/Pictures/RNA_Seq_Task1/10.1.7.2.ppi_full_network_modules.png" target="_blank" rel="noopener">
      <img src="https://mohammadrezamohajeri.github.io/Main_Portfolio/Pictures/RNA_Seq_Task1/10.1.7.2.ppi_full_network_modules.png"
           alt="PPI network colored by Louvain modules with node size proportional to degree"
           style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); width: 85%; height: 80%;">
    </a>
    <figcaption id="figure-caption-10-1-7-2">
      Figure 10.1.7.2. Same network colored by Louvain modules (communities; â‰¥ 3 genes per module);
      node size reflects degree. Labels highlight the highest-degree hubs.
    </figcaption>
  </figure>

</div>

	


						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.8. ============================ -->
					    <h4>10.1.8. Section 8: GO enrichment panels per module </h4>

			<ul>
				 

				<li>
					This part examines <strong>biological coherence</strong> within <strong>modules</strong> with <strong>GO over-representation analysis</strong> via <strong>clusterProfiler::enrichGO</strong> for the <strong>chosen ontology</strong>. It ranks <strong>modules</strong> by their <strong>best adjusted P value</strong>, writes a <strong>CSV overview</strong> of <strong>enrichment scores</strong>, and, for the <strong>top modules</strong>, saves <strong>two visuals</strong> per <strong>module</strong>: a focused <strong>network subgraph</strong> colored by <strong>log2FC</strong> and a <strong>dotplot</strong> summarizing the most significant <strong>GO terms</strong>. Where available, <strong>patchwork</strong> composes the two into a single <strong>side-by-side panel</strong>, and full <strong>enrichment tables</strong> per <strong>module</strong> are exported to <strong>CSV</strong>. These <strong>outputs</strong> connect <strong>structure</strong> to <strong>function</strong> by showing what <strong>processes</strong> dominate each <strong>module</strong> and which <strong>genes</strong> drive those termsâ€”useful for interpreting <strong>pathways</strong> relevant to <strong>atopic dermatitis</strong>.
				</li>


				<li>
					<strong>What this section does & what it produces (in the order the code runs)</strong> â€” The block first <strong>tests GO enrichment per module</strong> but only for modules large enough to be meaningful in ORA, i.e. <strong>min_genes_module â‰¥ 5</strong>. With our settings (<strong>min_genes_module = 5</strong>, ontology <strong>ontol = "BP"</strong>), it runs <code>clusterProfiler::enrichGO()</code> for each remaining module, then for each enrichment table it records the <strong>best term</strong> (the row with the smallest <strong>adjusted P</strong>, with <strong>GeneRatio</strong> as a tie-breaker), and computes a module â€œstrengthâ€ <strong>score = âˆ’log10(best_p.adjust)</strong>. These one-line summaries are merged and saved as <strong>module_enrichment_overview.csv</strong> with columns <strong>module</strong>, <strong>n_genes</strong>, <strong>best_term</strong>, <strong>best_padj</strong>, <strong>n_sig_terms</strong> (number of terms with adj.P â‰¤ 0.05), and the <strong>score</strong>. This file is the sortable dashboard: <strong>best_term</strong> names the most characteristic process, <strong>best_padj</strong>/ <strong>score</strong> measure strength, <strong>n_sig_terms</strong> gives thematic breadth, and <strong>n_genes</strong> reminds us of the moduleâ€™s size. Next, the code makes two overview figures from that table: a <strong>bar plot of module enrichment scores</strong> (higher bars = stronger enrichment) and a <strong>â€œbest GO term per moduleâ€ plot</strong> that places each module by its score and labels it with its top BP termâ€”great for a quick narrative of â€œwho does what.â€ Finally, it selects the <strong>top N modules</strong> to visualize in detail, via <code>mods_to_plot <- head(enrich_summary$module, top_n_enriched)</code>. With our setting <strong>top_n_enriched = 3</strong>, thatâ€™s why this code generates files and figures for modules <strong>1, 7, and 11</strong>. For each of those, the code writes a full enrichment table <strong>module_<em>M</em>GO_BP.csv</strong> (all terms, not just the top one) and produces a <strong>combined panel</strong> image <strong>module<em>M</em>_combo.png</strong> that shows the <strong>module sub-network</strong> (FR layout; node size = within-module degree; node color = log2FC) side-by-side with a <strong>GO dot plot</strong> of the top terms (x = âˆ’log10 adj.P; dot size = hit <strong>Count</strong>). The per-module CSV includes the standard <strong>clusterProfiler</strong> fields youâ€™ll actually use: <strong>ID</strong> (GO id), <strong>Description</strong> (term name), <strong>GeneRatio</strong> (hits/genes in this module), <strong>BgRatio</strong> (hits/background genes), <strong>p.adjust</strong> (BH), <strong>geneID</strong> (hit list), and <strong>Count</strong> (hit number). Together, the overview table/plots tell you <em>which</em> modules matter most; the per-module CSV + combo figure tell you <em>why</em> (which processes) and <em>how</em> (which genes/edges).
				</li>

				<li>
					<strong>How it works, technically</strong> â€” The code uses <strong>igraph</strong>/<strong>tidygraph</strong>/<strong>ggraph</strong> for network geometry and <strong>clusterProfiler</strong> + <strong>org.Hs.eg.db</strong> for <code>enrichGO()</code>. After filtering modules by <strong>min_genes_module</strong>, it loops modules, calls <code>enrichGO(gene = symbols, OrgDb = org.Hs.eg.db, keyType = "SYMBOL", ont = ontol, pAdjustMethod = "BH", pvalueCutoff = 0.05)</code>, coerces the result to a data frame, orders by <strong>p.adjust</strong> (then by computed <strong>GeneRatioNum</strong>) to pick the â€œbest term,â€ and derives <strong>score = âˆ’log10(best_p.adjust)</strong>. It binds those rows, sorts by <strong>score</strong> (ties broken by <strong>n_genes</strong>), writes <strong>module_enrichment_overview.csv</strong>, and builds two ggplots: a <code>geom_col()</code> score bar chart and a <code>geom_point()</code> + <code>geom_text()</code> map of best terms. For detailed panels, it keeps the top <strong>top_n_enriched</strong> modules, induces each subgraph (<code>induced_subgraph()</code>), computes within-module degree, labels the top-degree hubs to reduce clutter, and plots a <strong>force-directed FR</strong> layout with faint edges, <strong>degree-scaled nodes</strong>, and a <strong>diverging log2FC</strong> color scale. The companion GO plot is built by a helper that ranks terms by <strong>p.adjust</strong>, keeps the top <strong>top_terms_show</strong>, and draws a <code>geom_point()</code> dot plot with <strong>âˆ’log10(adj.P)</strong> on the x-axis and dot size = <strong>Count</strong>. Optional <strong>patchwork</strong> stitches network and dot plot into a single <strong>combo</strong> PNG per module.
				</li>


				======================================
								<li> <strong>What this section does & what it produces (in the order the code runs)</strong>. At the start of 8.1, a helper function ,<strong>make_enrich_plot()</strong>, is defined. This function takes an <strong>enrichment result</strong> from <strong>enrichGO</strong> and turns it into a compact <strong>GO dot plot</strong>. It computes <strong>âˆ’log10(adj.P)</strong>, <strong>parses</strong> the GeneRatio into numeric form, <strong>orders</strong> terms by adjusted P-value (with GeneRatio as a tie-breaker), and <strong>keeps</strong> only the top N. It then <strong>draws</strong> a dot plot where the x-axis is âˆ’log10(adj.P), the y-axis is the GO terms, and dot size corresponds to the hit count. This function will later be <strong>called</strong> in section 8.2 when visualizing selected modules. In <strong>8.1</strong>, the code performs <strong>GO enrichment analysis</strong> for each <strong>network module</strong>. In <strong>8.1.1</strong>, it first filters modules to keep only those with at least <strong>min_genes_module â‰¥ 5</strong>, since very small modules are not reliable for ORA. With the settings here (<strong>min_genes_module = 5</strong>, ontology <strong>ontol = "BP"</strong>), it applies <strong>clusterProfiler::enrichGO()</strong> to each remaining module. From each enrichment result, it extracts the <strong>best term</strong>â€”defined as the row with the smallest adjusted p-value (using <strong>GeneRatio</strong> as a tie-breaker)â€”and calculates a <strong>module enrichment score</strong> as âˆ’log10(best adjusted p-value).

								In <strong>8.1.2</strong>, these one-line summaries are merged and written into <strong>module enrichment overview</strong> (CSV). This file includes the columns <strong>module</strong>, <strong>n_genes</strong>, <strong>best_term</strong>, <strong>best_padj</strong>, <strong>n_sig_terms</strong> (number of terms with adjusted p â‰¤ 0.05), and the <strong>score</strong>. Each column provides complementary insights: <strong>best_term</strong> names the most characteristic process, <strong>best_padj</strong> and <strong>score</strong> quantify its statistical strength, <strong>n_sig_terms</strong> indicates the thematic breadth of enrichment, and <strong>n_genes</strong> reminds us of the moduleâ€™s size.
								
								In <strong>8.1.3</strong>, two overview figures are generated from this table: (A) a <strong>bar plot of module enrichment scores</strong> where higher bars correspond to stronger enrichment, and (B) a <strong>plot of the best GO term per module</strong>, which positions modules by their score and labels them with their top BP term. These visualizations complement the CSV by giving an intuitive overview of which modules are most biologically meaningful.
								
								In <strong>8.1.4</strong>, the code selects the <strong>top N enriched modules</strong> for detailed analysis using <code>mods_to_plot <- head(enrich_summary$module, top_n_enriched)</code>. With <strong>top_n_enriched = 3</strong>, the three highest-scoring modules are chosen.
								
								Finally, in <strong>8.2</strong>, the code produces per-module outputs for these top modules. For each selected module, it writes a <strong>full enrichment CSV</strong> with all GO terms (not just the top one), containing the standard <strong>clusterProfiler</strong> fields: <strong>ID</strong> (GO identifier), <strong>Description</strong> (term name), <strong>GeneRatio</strong> (proportion of module genes in the term), <strong>BgRatio</strong> (proportion in the background), <strong>p.adjust</strong> (BH-corrected p-value), <strong>geneID</strong> (list of module genes associated), and <strong>Count</strong> (number of genes contributing). It also generates a <strong>combined panel image</strong> per module that shows side-by-side: (1) the <strong>sub-network</strong> of the module (FR layout; node size = within-module degree; node color = log2FC), and (2) a <strong>GO dot plot</strong> of the top enriched terms (x = âˆ’log10 adjusted p-value; dot size = hit count). These combined panels provide both structural and functional views of each enriched module.
								
								</li> <li> <strong>How it works, technically</strong> â€” The implementation relies on <strong>igraph</strong>, <strong>tidygraph</strong>, and <strong>ggraph</strong> for network handling and visualization, and on <strong>clusterProfiler</strong> plus <strong>org.Hs.eg.db</strong> for GO enrichment. In <strong>8.1.1</strong>, the code builds <strong>modules_list_f</strong> by filtering <strong>modules_list</strong> to include only modules meeting the size threshold. It then loops over these modules, runs <strong>enrichGO()</strong>, and coerces each result into a data frame. The rows are ordered by adjusted p-value (and by calculated <strong>GeneRatioNum</strong> if tied), from which the â€œbest termâ€ is selected. The moduleâ€™s <strong>score</strong> is derived as âˆ’log10(best adjusted p-value).
								
								In <strong>8.1.2</strong>, these summaries are bound into <strong>enrich_summary</strong>, sorted by score (with module size as a tie-breaker), and written as <strong>module enrichment overview.csv</strong>. In <strong>8.1.3</strong>, two ggplot-based outputs are created: a <strong>geom_col()</strong> bar chart of enrichment scores and a <strong>geom_point()</strong> + <strong>geom_text()</strong> plot of best terms.
								
								In <strong>8.1.4</strong>, the top N modules are selected via <strong>head()</strong>. Then in <strong>8.2</strong>, for each module, the code induces the subgraph (<strong>induced_subgraph()</strong>), computes within-module degree, and labels hub nodes to reduce clutter. The network is drawn with a <strong>force-directed FR layout</strong>, using faint edges, degree-scaled nodes, and a diverging log2FC color scale. The accompanying GO dot plot is created by the helper <strong>make_enrich_plot()</strong>, which ranks terms by adjusted p-value, keeps the top terms, and plots them with <strong>âˆ’log10(adj.P)</strong> on the x-axis and <strong>dot size = Count</strong>. If available, <strong>patchwork</strong> is used to stitch the two plots into a single <strong>combo panel PNG</strong>.
								
								Overall, this section combines <strong>a global overview</strong> of module enrichments with <strong>detailed panels</strong> for the most important modules, allowing both broad comparison and fine-grained interpretation.
								
								</li>
 #=#=#=#==#=#=#=#=#=#=#=#=#=#=#=##=#=#=#==#=#=#=#=#=#=#=#=#=#=#=##=#=#=#==#=#=#=#=#=#=#=#=#=#=#=#
 <li> <strong>What this section does & what it produces (in the order the code runs)</strong>. In 8.1, the code performs <strong>GO enrichment analysis</strong> for each <strong>network module</strong>. At the start of <strong>8.1</strong>, a helper function, <strong>make_enrich_plot()</strong>, is defined. This function takes an <strong>enrichment result</strong> from <strong>enrichGO</strong> and turns it into a compact <strong>GO dot plot</strong>. It computes <strong>âˆ’log10(adj.P)</strong>, parses the <strong>GeneRatio</strong> into numeric form, orders terms by <strong>adjusted P-value</strong> (with <strong>GeneRatio</strong> as a tie-breaker), and keeps only the <strong>top N</strong> (top_n = 10). It then draws a <strong>dot plot</strong> where the <strong>x-axis</strong> is <strong>âˆ’log10(adj.P)</strong>, the <strong>y-axis</strong> is the <strong>GO terms</strong>, and <strong>dot size</strong> corresponds to the <strong>hit count</strong>. This helper will later be used in <strong>8.2</strong> to visualize selected modules.

In <strong>8.1.1</strong>, the code performs <strong>GO enrichment analysis</strong> for each <strong>network module</strong>, but only keeps modules with at least <strong>min_genes_module â‰¥ 5</strong> genes, since very small modules are not reliable for ORA. With the current settings (<strong>min_genes_module = 5</strong>, ontology <strong>ontol = "BP"</strong>), it applies <strong>clusterProfiler::enrichGO()</strong> to each remaining module. From each <strong>enrichment result</strong>, it extracts the <strong>best term</strong>â€”the row with the smallest adjusted p-value (using <strong>GeneRatio </strong>as a tie-breaker)â€”and calculates a <strong>module enrichment score</strong> as <strong>âˆ’log10(best adjusted p-value)</strong>.

In <strong>8.1.2</strong>, these one-line summaries are merged into a single <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/module_enrichment_overview.csv&title=Module%20Enrichment%20Overview" target="_blank" rel="noopener"><strong>module enrichment overview</strong></a> (CSV). This file includes the columns <strong>module</strong>, <strong>n_genes</strong>, <strong>best_term</strong>, <strong>best_padj</strong>, <strong>n_sig_terms</strong> (number of significant GO terms with adjusted p â‰¤ 0.05), and <strong>score</strong>. Each of these columns provides complementary insights: <strong>best_term</strong> highlights the most characteristic biological process, <strong>best_padj</strong> and <strong>score</strong> quantify its statistical strength, <strong>n_sig_terms</strong> indicates the thematic breadth of enrichment, and <strong>n_genes</strong> records module size.
In <strong>8.1.3</strong>, the code generates two overview figures from this table: (1) a <strong>bar plot</strong> of <strong>module enrichment scores</strong> (<a href="#figure-10-1-8-1" onclick="highlightFigure('10-1-8-1')">Figure 10.1.8.1</a>) where higher bars indicate stronger enrichment; (2) a plot of the best<strong> GO term per module</strong> (<a href="#figure-10-1-8-2" onclick="highlightFigure('10-1-8-2')">Figure 10.1.8.2</a>), which positions each module by its score and labels it with its top BP term. These visualizations provide an intuitive overview of which modules are statistically strongest and what biological processes they represent.

In <strong>8.1.4</strong>, the code selects the <strong>top N enriched modules</strong> for detailed visualization using <strong>mods_to_plot <- head(enrich_summary$module, top_n_enriched)</strong>. With the setting <strong>top_n_enriched = 3</strong>, the <strong>3 highest-scoring modules</strong> are selected for detailed outputs. Finally, in <strong>8.2</strong>, the code produces <strong>per-module outputs</strong> for the <strong>top three enriched modules</strong> (11, 1, and 7), and the code also writes CSV files containing the <strong>GO enrichment results</strong> for <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/CSV_File_1_module_11_GO_BP.csv&title=Module%2011%20enrichment" target="_blank" rel="noopener"><strong>Module 11</strong></a>, <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/CSV_File_2_module_1_GO_BP.csv&title=Module%201%20enrichment" target="_blank" rel="noopener"><strong>Module 1</strong></a>, and <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/csv-viewer.html?src=https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/CSV_File_3_module_7_GO_BP.csv&title=Module%207%20enrichment" target="_blank" rel="noopener"><strong>Module 7</strong></a>. For every selected module, it writes a <strong>full enrichment CSV</strong> containing all enriched GO terms, with standard <strong>clusterProfiler</strong> fields: <strong>ID</strong> (GO identifier), <strong>Description</strong> (term name), <strong>GeneRatio</strong> (proportion of module genes involved), <strong>BgRatio</strong> (proportion in the background set), <strong>p.adjust</strong> (adjusted p-value, BH correction), <strong>geneID</strong> (list of associated genes), and <strong>Count</strong> (number of genes contributing). In addition, a <strong>combined panel image</strong> is generated for each module that shows side-by-side: (1) the <strong>sub-network</strong> of the module (FR layout; node size = within-module degree; node color = log2FC), and (2) the <strong>GO dot plot</strong> of the top enriched terms (x = âˆ’log10 adj.P, dot size = hit count). These combined figures integrate structural network context with functional biological interpretation. /// For the top three enriched modules, see the panels for <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/module_1_combo.png" target="_blank" rel="noopener"><strong>Module 1</strong></a>, <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/module_7_combo.png" target="_blank" rel="noopener"><strong>Module 7</strong></a>, and <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/module_11_combo.png" target="_blank" rel="noopener"><strong>Module 11</strong></a>.

</li> <li> <strong>How it works, technically</strong> â€” The implementation uses <strong>igraph</strong>, <strong>tidygraph</strong>, and <strong>ggraph</strong> for network handling and visualization, and <strong>clusterProfiler</strong> plus <strong>org.Hs.eg.db</strong> for GO enrichment analysis. In <strong>8.1.1</strong>, the code builds <strong>modules_list_f</strong> by filtering <strong>modules_list</strong> to retain only modules that meet the size threshold. It then loops over these modules, applies <strong>enrichGO()</strong>, and coerces each result into a data frame. The rows are ordered by adjusted p-value (with <strong>GeneRatioNum</strong> as a tie-breaker if needed), and the â€œbest termâ€ is extracted. A moduleâ€™s <strong>enrichment score</strong> is then calculated as âˆ’log10(best adjusted p-value).

In <strong>8.1.2</strong>, the summaries are combined into <strong>enrich_summary</strong>, sorted by score (with module size as a secondary factor), and written as <strong>module enrichment overview.csv</strong>. In <strong>8.1.3</strong>, the code builds two ggplot2 outputs: a <strong>geom_col()</strong> bar chart of enrichment scores and a <strong>geom_point()</strong> + <strong>geom_text()</strong> visualization of best terms.

In <strong>8.1.4</strong>, the top N modules are selected via <strong>head()</strong>. Then in <strong>8.2</strong>, the code induces the <strong>subgraph</strong> for each selected module (<strong>induced_subgraph()</strong>), computes within-module degree, and labels hub nodes to avoid clutter. The module network is drawn with a <strong>force-directed FR layout</strong>, using faint edges, degree-scaled nodes, and a diverging log2FC color gradient. The companion GO plot is generated by <strong>make_enrich_plot()</strong>, which ranks enriched terms by adjusted p-value, keeps the top terms, and plots them against âˆ’log10(adj.P) with <strong>dot size = Count</strong>. If the <strong>patchwork</strong> package is available, it combines both plots into a single <strong>combo panel PNG</strong>.

Overall, this section integrates <strong>a global overview of module enrichment</strong> with <strong>detailed structural and functional panels</strong> for the top modules, giving both high-level prioritization and deep biological insight.

</li>
				
#=#=#=#==#=#=#=#=#=#=#=#=#=#=#=##=#=#=#==#=#=#=#=#=#=#=#=#=#=#=##=#=#=#==#=#=#=#=#=#=#=#=#=#=#=#
				
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.8.  code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.8. GO Enrichment per Module â€” Rank modules and plot network + GO dotplot panels </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
# enrich_summary 
# ==========================================================
# [Section 8/9] Enrichment-driven module panels (PNGs + CSVs)
#    - Rank modules by best adj.P (GO); per-module network + GO dotplot
# ==========================================================
 
 # 8.1 Rank modules by enrichment and write overview CSV
# -----------------------------------------------------
# Helper function: Create GO dotplot for a module
make_enrich_plot <- function(eg, mod_id, top_n = 10) {
  # Convert enrichGO result to a data frame (returns NULL if error)
  df <- tryCatch(as.data.frame(eg), error = function(e) NULL)
  
  # If no enrichment results, return a placeholder empty plot
  if (is.null(df) || nrow(df) == 0) {
    return(ggplot() + theme_void() +
             ggtitle(paste("No significant GO terms for module", mod_id)))
  }
  
  # Add â€“log10 adjusted p-values for ranking/plotting
  df$neglog10padj <- -log10(df$p.adjust)
  
  # Convert GeneRatio from "5/20" to numeric (0.25)
  df$GeneRatioNum <- vapply(strsplit(df$GeneRatio, "/"),
                            function(x) as.numeric(x[1]) / as.numeric(x[2]),
                            numeric(1))
  
  # Rank terms by adjusted p-value (smallest first), then by gene ratio
  df <- df[order(df$p.adjust, -df$GeneRatioNum), ]
  
  # Keep only the top N terms (default 10)
  df <- head(df, top_n)

  # Create dot plot:
  #   x = â€“log10(adj P), y = GO terms, dot size = gene count
  ggplot(df, aes(x = neglog10padj,
                 y = reorder(Description, neglog10padj),
                 size = Count)) +
    geom_point() +
    labs(x = "-log10(adj P)", y = NULL,
         title = paste0("GO ", ontol, " enrichment â€¢ module ", mod_id)) +
    theme_minimal(base_size = 11)
}
	    

# 8.1.1 Run enrichment per module and extract one-line summaries:
#   - Start with modules_list, which contains all detected modules (module ID â†’ vector of genes).
#   - Very small modules (fewer than min_genes_module genes) usually cannot produce reliable GO enrichment.
#   - Therefore, we filter modules_list to keep only those with at least min_genes_module genes (e.g., â‰¥5 genes).
#   - The result, modules_list_f, is the filtered list of modules used for all downstream enrichment analysis.
modules_list_f <- modules_list[sapply(modules_list, length) >= min_genes_module]

# For each module, run enrichGO and extract a one-line summary (best term and its adjusted p-value). 
# tryCatch ensures a single module failure doesn't stop the whole panel generation.
enrich_per_module <- lapply(names(modules_list_f), function(m) {
  gsym <- unique(modules_list_f[[m]])
  eg <- tryCatch(
    enrichGO(gene = gsym, OrgDb = org.Hs.eg.db, keyType = "SYMBOL",
             ont = ontol, pAdjustMethod = "BH", pvalueCutoff = 0.05, readable = TRUE),
    error = function(e) NULL
  )
  df <- tryCatch(as.data.frame(eg), error = function(e) NULL)
  if (!is.null(df) && nrow(df) > 0) {
    best <- df[order(df$p.adjust, df$pvalue), ][1, ]
    data.frame(module = m, n_genes = length(gsym),
               best_term = best$Description, best_padj = best$p.adjust,
               n_sig_terms = sum(df$p.adjust <= 0.05),
               score = -log10(best$p.adjust), stringsAsFactors = FALSE)
  } else {
    data.frame(module = m, n_genes = length(gsym),
               best_term = NA_character_, best_padj = NA_real_,
               n_sig_terms = 0, score = 0, stringsAsFactors = FALSE)
  }
})

# 8.1.2 Generate enrichment summary table (sortable CSV):
#  - Overview of enrichment across modules (sortable CSV used to pick top modules for plotting).
enrich_summary <- do.call(rbind, enrich_per_module)
enrich_summary <- enrich_summary[order(-enrich_summary$score, -enrich_summary$n_genes), ]
write.csv(enrich_summary, file.path(fig_dir, "module_enrichment_overview.csv"), row.names = FALSE)

 
# 8.1.3 Create overview plots from enrich_summary
library(ggplot2)
library(stringr)

# keep modules that were tested and have a score (score = -log10(best_padj))
enrich_plot_df <- subset(enrich_summary, is.finite(score) & score > 0)

# order modules by score (desc), then by size to keep ties stable
enrich_plot_df$module <- factor(
  enrich_plot_df$module,
  levels = enrich_plot_df$module[order(-enrich_plot_df$score, -enrich_plot_df$n_genes)]
)

# 8.1.3 (A) Bar chart of enrichment scores per module
p_scores <- ggplot(enrich_plot_df,
                   aes(x = module, y = score, fill = module)) +
  geom_col(width = 0.8, color = "grey60") +
  geom_text(aes(label = round(score, 1)), vjust = -0.35, size = 3) +
  scale_fill_viridis_d(option = "C", end = 0.95, guide = "none") +
  labs(x = "Module ID", y = "-log10(best adj P)",
       title = "Module enrichment scores") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank(),
        plot.title = element_text(face = "bold", size = 16),
        axis.title = element_text(face = "bold")) +
  expand_limits(y = max(enrich_plot_df$score, na.rm = TRUE) * 1.12)

ggsave(file.path(fig_dir, "module_enrichment_scores_barplot.png"),
       p_scores, width = 8, height = 4.5, dpi = 320, bg = "white")


# 8.1.3 (B) Best term per module (dot + label), positioned by score
# Wrap long term names so labels donâ€™t run off the page
enrich_plot_df$best_term_wrapped <- stringr::str_wrap(enrich_plot_df$best_term, width = 40)

p_best <- ggplot(enrich_plot_df,
                 aes(x = score, y = reorder(module, score))) +
  geom_point(size = 2.8) +
  geom_text(aes(label = best_term_wrapped),
            hjust = 0, nudge_x = 0.25, size = 3) +
  labs(x = "-log10(best adj P)", y = "Module ID",
       title = "Top GO BP term per module") +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(face = "bold", size = 16)) +
  # leave space on the right for labels
  coord_cartesian(xlim = c(0, max(enrich_plot_df$score, na.rm = TRUE) * 1.35))

ggsave(file.path(fig_dir, "module_enrichment_best_terms.png"),
       p_best, width = 10, height = 5.5, dpi = 320, bg = "white")
# ============================================================================




# 8.1.4 Pick the top N modules by enrichment score, -log10(best adjusted p-value),  for detailed panels
mods_to_plot <- head(enrich_summary$module, top_n_enriched)



# 8.2 Per-module network + GO dotplot (+ optional combined)
# Loop over selected modules: save network + GO dotplot (+ combined)
for (m in mods_to_plot) {
  # 8.2.1 Write full enrichment table for this module
  gsym <- unique(modules_list_f[[m]])
  eg <- tryCatch(
    enrichGO(gene = gsym, OrgDb = org.Hs.eg.db, keyType = "SYMBOL",
             ont = ontol, pAdjustMethod = "BH", pvalueCutoff = 0.05, readable = TRUE),
    error = function(e) NULL
  )
  
  # Inside the loop: write full enrichment table for transparency and later interpretation.
  df_full <- tryCatch(as.data.frame(eg), error = function(e) NULL)
  if (!is.null(df_full) && nrow(df_full) > 0) {
    write.csv(df_full, file.path(fig_dir, paste0("module_", m, "_GO_", ontol, ".csv")), row.names = FALSE)
  }

  # 8.2.2 Build and plot network for this module, sized by within-module degree.
  g_sub <- induced_subgraph(g, vids = V(g)[module == m])
  deg_sub <- degree(g_sub)
  V(g_sub)$deg_sub <- deg_sub

  # Label only the highest-degree nodes within this module to keep the network legible.
  label_ids <- names(sort(deg_sub, decreasing = TRUE))[seq_len(min(n_labels_per_net, length(deg_sub)))]
  label_flag <- ifelse(V(g_sub)$name %in% label_ids, V(g_sub)$label, "")

  # Network plot for this module (FR layout, sized by degree, colored by LFC)
  tg_sub <- as_tbl_graph(g_sub)
  set.seed(42)
  p_net <- ggraph(tg_sub, layout = "fr") +
    geom_edge_link0(edge_width = 0.25, edge_alpha = 0.25, colour = "gray40") +
    geom_node_point(aes(size = deg_sub, color = lfc)) +
    ggraph::geom_node_text(aes(label = label_flag), repel = TRUE, size = 3) +
    scale_size(range = c(2.5, 7), name = "Degree") +
    scale_color_gradient2(low = "steelblue", mid = "grey85", high = "firebrick",
                          midpoint = 0, name = "log2FC") +
    ggtitle(paste0("Module ", m, " network (n=", vcount(g_sub), ")")) +
    theme_void() +
  theme(
    plot.title       = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.background  = element_rect(fill = "white", colour = NA),
    panel.background = element_rect(fill = "white", colour = NA)
  )
  

  # 8.2.3 GO dotplot for this module (top terms)
  p_enr <- make_enrich_plot(eg, m, top_n = top_terms_show) +
    theme(
    plot.background  = element_rect(fill = "white", colour = NA),
    panel.background = element_rect(fill = "white", colour = NA)
  )

  # 8.2.4 Save outputs:
  # Save per-module network and GO dotplot figures.
  ggsave(file.path(fig_dir, paste0("module_", m, "_network.png")), p_net, width = 7, height = 5, dpi = 300, bg = "white")
  ggsave(file.path(fig_dir, paste0("module_", m, "_GO_", ontol, "_dotplot.png")), p_enr, width = 6, height = 5, dpi = 300, bg = "white")

    # 8.2.5 combined panel (network + enrichment)
  # If patchwork is available, also save a side-by-side composite (network + enrichment) for quick review.
  if (requireNamespace("patchwork", quietly = TRUE)) {
    combined <- p_net + p_enr + patchwork::plot_layout(widths = c(1.6, 1))
    ggsave(file.path(fig_dir, paste0("module_", m, "_combo.png")), combined, width = 12, height = 5, dpi = 300, bg = "white")
  }
}


 


		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->


 <!-- ======================= start Figure 10.1.8.1 /2============================ -->


		<!-- Module enrichment overview plots (Section 10.1.8) -->
<div style="display: flex; justify-content: space-around; flex-wrap: nowrap; gap: 16px;">

  <!-- Figure 10.1.8.1 â€” Module enrichment scores -->
  <figure id="figure-10-1-8-1" style="text-align: justify; margin: 10px; width: 48%;">
    <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.1.module_enrichment_scores_barplot.png" target="_blank" rel="noopener">
      <img src="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.1.module_enrichment_scores_barplot.png"
           alt="Bar plot of enrichment scores per module"
           style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); width: 100%; height: 300px;">
    </a>
    <figcaption id="figure-caption-10-1-8-1">
      Figure 10.1.8.1. Bar plot of enrichment scores for each module (âˆ’log10 of the best adjusted p-value). Higher bars indicate stronger enrichment, allowing modules to be ranked by statistical strength.
    </figcaption>
  </figure>

  <!-- Figure 10.1.8.2 â€” Best GO term per module -->
  <figure id="figure-10-1-8-2" style="text-align: justify; margin: 10px; width: 48%;">
    <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.2.module_enrichment_best_terms.png" target="_blank" rel="noopener">
      <img src="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.2.module_enrichment_best_terms.png"
           alt="Plot of best GO terms per module with enrichment scores"
           style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); width: 100%; height: 300px;">
    </a>
    <figcaption id="figure-caption-10-1-8-2">
      Figure 10.1.8.2. Plot of the best GO BP term per module, positioned by its enrichment score (âˆ’log10 adjusted p-value). Labels display the top biological process term for each module.
    </figcaption>
  </figure>

</div>

 <!-- ======================= End Figure 10.1.8.1 / 2 ============================ -->

<br>
<br>
		
 <!-- ========= Start Figure 10.1.8.3/ Figure 10.1.8.4 / Figure 10.1.8.5 ============================ -->
<!-- Top-enriched module combo panels (Section 10.1.8) -->
<div style="display: flex; justify-content: space-around; flex-wrap: nowrap; gap: 16px;">

  <!-- Figure 10.1.8.3 â€” Module 11 combo -->
  <figure id="figure-10-1-8-3" style="text-align: justify; margin: 10px; width: 32%;">
    <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.3.module_11_combo.png" target="_blank" rel="noopener">
      <img
        src="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.3.module_11_combo.png"
        alt="Module 11 network and GO BP dot plot"
        style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); width: 100%; height: 300px;">
    </a>
    <figcaption id="figure-caption-10-1-8-3">
      <strong>Figure 10.1.8.3.</strong> <strong>Module 11</strong> â€” sub-network (FR layout; node size = within-module degree; node color = log2FC) alongside the <strong>GO BP</strong> dot plot of top enriched terms (x = âˆ’log10 adj.P; dot size = hit count).
    </figcaption>
  </figure>

  <!-- Figure 10.1.8.4 â€” Module 1 combo -->
  <figure id="figure-10-1-8-4" style="text-align: justify; margin: 10px; width: 32%;">
    <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.4.module_1_combo.png" target="_blank" rel="noopener">
      <img
        src="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.4.module_1_combo.png"
        alt="Module 1 network and GO BP dot plot"
        style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); width: 100%; height: 300px;">
    </a>
    <figcaption id="figure-caption-10-1-8-4">
      <strong>Figure 10.1.8.4.</strong> <strong>Module 1</strong> â€” sub-network (FR layout; node size = within-module degree; node color = log2FC) and <strong>GO BP</strong> dot plot of the top terms.
    </figcaption>
  </figure>

  <!-- Figure 10.1.8.5 â€” Module 7 combo -->
  <figure id="figure-10-1-8-5" style="text-align: justify; margin: 10px; width: 32%;">
    <a href="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.5.module_7_combo.png" target="_blank" rel="noopener">
      <img
        src="https://mohammadrezamohajeri.github.io/Main_Portfolio/RNA_Seq_Task1_Files/10.1.8.5.module_7_combo.png"
        alt="Module 7 network and GO BP dot plot"
        style="display: block; background-color: #0c4b4f; padding: 10px; border-radius: 15px; box-shadow: 0px 4px 8px rgba(0,0,0,0.2); width: 100%; height: 300px;">
    </a>
    <figcaption id="figure-caption-10-1-8-5">
      <strong>Figure 10.1.8.5.</strong> <strong>Module 7</strong> â€” sub-network (FR layout; node size = within-module degree; node color = log2FC) and <strong>GO BP</strong> dot plot of the top terms.
    </figcaption>
  </figure>

</div>

 <!-- ========= End Figure 10.1.8.3/ Figure 10.1.8.4 / Figure 10.1.8.5 ============================ -->



						
 <!-- ======================= ======= ============================ -->
 <!-- ======================= 10.1.9. ============================ -->
					    <h4>10.1.9. Section 9: Centrality metrics and module-level summaries  </h4>

			<ul>
				 

				<li>
                 Finally, the workflow quantifies <strong>node importance</strong> using <strong>standard centralities</strong> from <strong>igraph</strong>. It defines a <strong>shortest-path distance</strong> as the <strong>inverse of STRING score</strong> so <strong>stronger interactions</strong> are â€œcloser,â€ then computes <strong>degree</strong> (and <strong>normalised degree</strong>), <strong>weighted strength</strong>, <strong>betweenness</strong> and <strong>closeness</strong> on the <strong>distance metric</strong>, and <strong>eigenvector centrality</strong> on the <strong>raw scores</strong>. A <strong>node-level CSV</strong> records <strong>all metrics</strong> per gene, and a <strong>module-level summary</strong> aggregates <strong>means and medians</strong> and identifies the <strong>top-degree hub</strong> in each <strong>module</strong>. These <strong>tables</strong> support ranking <strong>candidate biomarkers</strong> or <strong>targets</strong>, comparing <strong>modules</strong> by their <strong>internal connectivity</strong>, and cross-referencing <strong>highly central genes</strong> with <strong>enriched processes</strong> discovered earlier.
				</li>
			</ul>

 <!-- ======================== CODE START ============================ -->
		<!-- ======= 10.1.9. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 10.1.9. Centrality Metrics & Module-Level Summaries â€” Degree/strength, betweenness/closeness/eigenvector, CSV exports </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		 

# ==========================================================
# [Section 9/9] Centrality metrics & module-level summaries (CSVs)
#    - Degree/strength; betweenness/closeness on 1/score; eigenvector
# ==========================================================
# 
 
# 9.1 Define edge distance for shortest paths
# Higher STRING score = stronger/closer connection, so use 1/score as distance.
E(g)$dist <- 1 / pmax(E(g)$combined_score, .Machine$double.eps)

# 9.2 Compute a small panel of standard centralities:
# - Degree (unweighted) and normalized degree
# - degree (local connectivity)
deg_unw   <- degree(g)                       # already in V(g)$deg, recompute for clarity
# degree_norm (scaled 0â€“1)
deg_norm  <- if (vcount(g) > 1) deg_unw / (vcount(g) - 1) else deg_unw

# - Strength (weighted degree by STRING score)
strength_w <- strength(g, weights = E(g)$combined_score)

# - Betweenness (weighted by distance)
btw_w <- betweenness(g, weights = E(g)$dist, directed = FALSE, normalized = TRUE)

# - Closeness (weighted by distance)
clo_w <- closeness(g, weights = E(g)$dist, normalized = TRUE)
clo_w[!is.finite(clo_w)] <- NA  # guard against Inf/NaN in disconnected cases

# - Eigenvector centrality (use score as weight, not distance/ influence via well-connected neighbors)
eig_w <- eigen_centrality(g, weights = E(g)$combined_score,
                          directed = FALSE, scale = TRUE)$vector


# 9.3 Export node-level centrality table
# Assemble a tidy per-node centrality table for export and ranking/plotting in downstream tools.
cent_df <- data.frame(
  STRING_id     = V(g)$name,
  gene          = V(g)$label,
  module        = as.character(V(g)$module),
  degree        = deg_unw,
  degree_norm   = deg_norm,
  strength_w    = strength_w,
  betweenness_w = btw_w,
  closeness_w   = clo_w,
  eigenvector   = eig_w,
  lfc           = V(g)$lfc,
  padj          = V(g)$padj,
  stringsAsFactors = FALSE
)

# Sort within each module by degree so the top hubs float to the top of each group in the CSV.
cent_df <- cent_df[order(as.numeric(cent_df$module), -cent_df$degree), ]

# Save node-level centralities
write.csv(cent_df, file.path(fig_dir, "ppi_node_centrality.csv"), row.names = FALSE)


# 9.4 Export module-level summary (size, means, medians, top hub (by degree)
# Module size
mod_sizes <- as.data.frame(table(cent_df$module), stringsAsFactors = FALSE)
names(mod_sizes) <- c("module", "n_genes")


# Means across nodes in each module
mod_means <- aggregate(
  cent_df[, c("degree","degree_norm","strength_w","betweenness_w","closeness_w","eigenvector")],
  by = list(module = cent_df$module),
  FUN = function(x) mean(x, na.rm = TRUE)
)
names(mod_means)[-1] <- paste0(names(mod_means)[-1], "_mean")

# Medians across nodes in each module
mod_meds <- aggregate(
  cent_df[, c("degree","degree_norm","strength_w","betweenness_w","closeness_w","eigenvector")],
  by = list(module = cent_df$module),
  FUN = function(x) median(x, na.rm = TRUE)
)
names(mod_meds)[-1] <- paste0(names(mod_meds)[-1], "_median")

# Identify a simple top hub per module (by highest degree). Other choices (e.g., strength) are possible.
top_hub <- tapply(seq_len(nrow(cent_df)), cent_df$module, function(idx) {
  i <- idx[which.max(cent_df$degree[idx])]
  cent_df$gene[i]
})
top_hub_df <- data.frame(module = names(top_hub), top_hub_gene = unname(unlist(top_hub)),
                         stringsAsFactors = FALSE)

# Merge all summaries
module_centrality_summary <- Reduce(function(x, y) merge(x, y, by = "module", all = TRUE),
                                    list(mod_sizes, mod_means, mod_meds, top_hub_df))

# Order modules by descending size (then numeric id) in the final summary for quick, consistent browsing.
module_centrality_summary$module_num <- as.numeric(module_centrality_summary$module)
module_centrality_summary <- module_centrality_summary[order(-module_centrality_summary$n_genes,
                                                             module_centrality_summary$module_num), ]
module_centrality_summary$module_num <- NULL

# Save per-module summaryLondon Luton Airport
write.csv(module_centrality_summary,
          file.path(fig_dir, "ppi_module_centrality_summary.csv"), row.names = FALSE)


		    </code></pre>
		</div>
<!-- ======================== CODE END ============================ -->
<!-- ======================= ======= ======================  ====== -->





						


 

 

			

<!-- ======================================================================================== -->
		
		    <h3>10.2. GSEA for Gene Ontology (GO) Enrichment (BP, MF, CC)</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 10.2.		     
		      </li>
		     </ul> 

			
		    <h3>o	10.3. ORA for KEGG Pathway Enrichment</h3>
 		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR 10.3.		     
		      </li>
		     </ul> 

			 


				 



		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 9.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 9.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### --> 




	
<h3>Bellow is the old section, should be removed after checking</h3>

        <div class="explanation">
            <h3>6. Create DESeqDataSet and Run Differential Expression Analysis</h3>
            <p>We create a <code>DESeqDataSet</code> object, normalize the data, and run the differential expression analysis using DESeq2. This model tests for differences in gene expression between the Lesional and Non-Lesional groups.</p>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Create DESeqDataSet and run DESeq2
ds <- DESeqDataSetFromMatrix(countData=tbl, colData=sample_info, design= ~Group)
ds <- DESeq(ds, test="Wald", sfType="poscount")
            </code></pre>
        </div>

        <div class="explanation">
            <h3>7. Extract and Process Results</h3>
            <p>We extract the results from DESeq2, separating the differentially expressed genes (DEGs) into upregulated and downregulated categories, and prepare the top genes for further analysis.</p>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Extract results for top genes
r <- results(ds, contrast = c("Group", groups[1], groups[2]), alpha = 0.01, pAdjustMethod = "fdr")

# Separate downregulated and upregulated DEGs
downregulated <- r[r$log2FoldChange < 0 & r$padj < 0.01, ]
upregulated <- r[r$log2FoldChange > 0 & r$padj < 0.01, ]

# Take the top 10 genes for downregulated and upregulated
top_downregulated <- downregulated[order(downregulated$log2FoldChange)[1:10], ]
top_upregulated <- upregulated[order(upregulated$log2FoldChange, decreasing = TRUE)[1:10], ]

# Merge with gene annotations
top_downregulated <- merge(as.data.frame(top_downregulated), annot, by = 0, sort = FALSE)
top_upregulated <- merge(as.data.frame(top_upregulated), annot, by = 0, sort = FALSE)

# Round "padj" and "log2FoldChange" columns for readability
top_downregulated <- within(top_downregulated, {
  padj <- sprintf("%.4f", round(padj, 2))
  log2FoldChange <- sprintf("%.4f", round(log2FoldChange, 2))
})

top_upregulated <- within(top_upregulated, {
  padj <- sprintf("%.4f", round(padj, 2))
  log2FoldChange <- sprintf("%.4f", round(log2FoldChange, 2))
})

# Print the top_downregulated table using kable
kable(top_downregulated, format = "markdown")
kable(top_upregulated, format = "markdown")
            </code></pre>
        </div>

        <div class="explanation">
            <h3>8. General Data Visualization</h3>
            <p>We generate various plots to visualize the data and the results of the differential expression analysis.</p>

            <h4>8.1 Box Plot</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Box-and-whisker plot
dat <- log10(counts(ds, normalized = T) + 1)
ord <- order(gs)
palette(c("#1B9E77", "#7570B3"))
par(mar=c(7,4,2,1))
boxplot(dat[,ord], boxwex=0.6, notch=T, main="GSE157194", ylab="lg(norm.counts)", outline=F, las=2, col=gs[ord])
legend("topleft", groups, fill=palette(), bty="n")
            </code></pre>
        </div>

        <div class="explanation">
            <h4>8.2 Dispersion Estimates</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Dispersion estimates plot
plotDispEsts(ds, main="GSE157194 Dispersion Estimates")
            </code></pre>
        </div>

        <div class="explanation">
            <h4>8.3 UMAP Plot</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# UMAP plot
dat <- dat[!duplicated(dat), ]
par(mar=c(3,3,2,6), xpd=TRUE, cex.main=1.5)
ump <- umap(t(dat), n_neighbors = 15, random_state = 123)
plot(ump$layout, main="UMAP plot, nbrs=15", xlab="", ylab="", col=gs, pch=20, cex=1.5)
legend("topright", inset=c(-0.15,0), legend=groups, pch=20, col=1:length(groups), title="Group", pt.cex=1.5)
            </code></pre>
        </div>

        <div class="explanation">
            <h4>8.4 Histogram of P-values</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Histogram of adjusted p-values
hist(r$padj, breaks=seq(0, 1, length = 21), col = "grey", border = "white", 
     xlab = "", ylab = "", main = "GSE157194 Frequencies of padj-values")
            </code></pre>
        </div>

        <div class="explanation">
            <h4>8.5 Volcano Plot</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Volcano plot
old.pal <- palette(c("#00BFFF", "#FF3030"))
par(mar=c(4,4,2,1), cex.main=1.5)
plot(r$log2FoldChange, -log10(r$padj), main=paste(groups[1], "vs", groups[2]),
     xlab="log2FC", ylab="-log10(Padj)", pch=20, cex=0.5)
with(subset(r, padj<0.01 & abs(log2FoldChange) >= 1.5),
     points(log2FoldChange, -log10(padj), pch=20, col=(sign(log2FoldChange) + 3)/2, cex=1))
legend("bottomleft", title=paste("Padj<", 0.01, sep=""), legend=c("down", "up"), pch=20,col=1:2)
            </code></pre>
        </div>

        <div class="explanation">
            <h4>8.6 MA Plot</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# MA plot
par(mar=c(4,4,2,1), cex.main=1.5)
plot(log10(r$baseMean), r$log2FoldChange, main=paste(groups[1], "vs", groups[2]),
     xlab="log10(mean of normalized counts)", ylab="log2FoldChange", pch=20, cex=0.5)
with(subset(r, padj<0.01 & abs(log2FoldChange) >= 1.5),
     points(log10(baseMean), log2FoldChange, pch=20, col=(sign(log2FoldChange) + 3)/2, cex=1))
legend("bottomleft", title=paste("Padj<", 0.01, sep=""), legend=c("down", "up"), pch=20,col=1:2)
abline(h=0)
palette(old.pal)
            </code></pre>
        </div>

        <div class="explanation">
            <h3>9. Functional Annotation and Pathway Analysis</h3>
            <p>After identifying DEGs, we perform GO and KEGG pathway enrichment analyses to understand the biological significance of the results.</p>

            <h4>9.1 Gene Ontology (GO) Enrichment Analysis</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# GO enrichment analysis for upregulated and downregulated genes
up_genes <- top_upregulated$GeneID
down_genes <- top_downregulated$GeneID

# GO enrichment for upregulated genes
ego_up <- enrichGO(gene = up_genes, OrgDb = org.Hs.eg.db, keyType = "ENSEMBL",
                   ont = "BP", pAdjustMethod = "fdr", qvalueCutoff = 0.05)

# GO enrichment for downregulated genes
ego_down <- enrichGO(gene = down_genes, OrgDb = org.Hs.eg.db, keyType = "ENSEMBL",
                     ont = "BP", pAdjustMethod = "fdr", qvalueCutoff = 0.05)

# Plotting the top GO terms
barplot(ego_up, showCategory=10, title="Top GO terms for Upregulated Genes", drop=TRUE)
barplot(ego_down, showCategory=10, title="Top GO terms for Downregulated Genes", drop=TRUE)
            </code></pre>
        </div>

        <div class="explanation">
            <h4>9.2 KEGG Pathway Enrichment Analysis</h4>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# KEGG pathway enrichment analysis for upregulated and downregulated genes
kegg_up <- enrichKEGG(gene = up_genes, organism = "hsa", pAdjustMethod = "fdr", qvalueCutoff = 0.05)
kegg_down <- enrichKEGG(gene = down_genes, organism = "hsa", pAdjustMethod = "fdr", qvalueCutoff = 0.05)

# Plotting the top KEGG pathways
barplot(kegg_up, showCategory=10, title="Top KEGG Pathways for Upregulated Genes")
barplot(kegg_down, showCategory=10, title="Top KEGG Pathways for Downregulated Genes")
            </code></pre>
        </div>

        <div class="explanation">
            <h3>10. Venn Diagram for Gene Sets</h3>
            <p>We visualize the overlap between different gene sets (total, upregulated, downregulated) using a Venn diagram.</p>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Venn diagram for gene sets
total_genes <- rownames(tbl)
upregulated_genes <- rownames(top_upregulated)
downregulated_genes <- rownames(top_downregulated)

venn_data <- list(
  Total = total_genes,
  Upregulated = upregulated_genes,
  Downregulated = downregulated_genes
)

venn_plot <- venn.diagram(
  x = venn_data,
  category.names = c("Total", "Upregulated", "Downregulated"),
  filename = NULL,
  margin = 0,
  cex.prop = 0.8,
  offset.prop = 0.2
)

grid.draw(venn_plot)
            </code></pre>
        </div>

        <div class="explanation">
            <h3>11. Extract Top 20 Genes and Print Results</h3>
            <p>Finally, we extract the top 20 differentially expressed genes from both categories and print the results.</p>
        </div>

        <div class="code-block">
            <pre><code class="language-r">
# Extract results for top genes table (rounded)
r <- results(ds, contrast = c("Group", groups[1], groups[2]), alpha = 0.01, pAdjustMethod = "fdr")

# Separate downregulated and upregulated DEGs
downregulated <- r[r$log2FoldChange < 0 & r$padj < 0.01, ]
upregulated <- r[r$log2FoldChange > 0 & r$padj < 0.01, ]

# Take the top 20 genes for downregulated and upregulated
top_downregulated <- downregulated[order(downregulated$log2FoldChange)[1:20], ]
top_upregulated <- upregulated[order(upregulated$log2FoldChange, decreasing = TRUE)[1:20], ]

# Merge with gene annotations
top_downregulated <- merge(as.data.frame(top_downregulated), annot, by = 0, sort = FALSE)
top_upregulated <- merge(as.data.frame(top_upregulated), annot, by = 0, sort = FALSE)

# Round "padj" and "log2FoldChange" columns
top_downregulated <- within(top_downregulated, {
  padj <- sprintf("%.4f", round(padj, 4))
  log2FoldChange <- sprintf("%.4f", round(log2FoldChange, 4))
 })

top_upregulated <- within(top_upregulated, {
  padj <- sprintf("%.4f", round(padj, 4))
  log2FoldChange <- sprintf("%.4f", round(log2FoldChange, 4))
})

# Print the top_downregulated table using kable
kable(top_downregulated, format = "markdown") 
kable(top_upregulated, format = "markdown")
            </code></pre>
        </div>

        <div class="explanation">
            <h3>Conclusion</h3>
            <p>This complete pipeline guides you through performing differential gene expression analysis on the GSE157194 dataset using DESeq2. The analysis identifies significant gene expression changes between lesional and non-lesional skin samples from Atopic Dermatitis patients, and includes essential data visualizations and enrichment analyses to interpret the results biologically.</p>
        </div>
    </div>



	  		 <!-- #################################### bellow is just a sample, can be deleted later############################################### --> 

		 <!-- ################################################################################### --> 

<!-- ========================================= Main title e.g. 3.  ======================================== -->
		<div class="explanation">
		    <h3>3.TTTTTTTTTTTTITTTTLLLLLLLLLLLLLLLLE</h3>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR ONE PARAGRAPH.		     
		      </li>
		    </ul> 
		</div>
<!-- ======================================== Sub title e.g. 3.1.================================================ -->
		<div class="explanation">
		    <h3>3.1. SUBBBBBB TITTTTLLLLE</h3>
			<h4 style="margin-top: 5px;">3.1.1. THIRDDDDDD SUBTITLE </h4>
		    <ul>
	   	      <li>
			TEXTTTTTTTTTTT FOR ONE PARAGRAPH.		     
		      </li>
		     </ul> 
		</div>


	  <!-- ======================== CODE START ============================ -->
		<!-- ======= 3.1. code chunk =========== -->
		<!-- Caption for the code block -->
		<p class="code-caption">Code Block 3.1.1.  CODDDDDE BLLLOOOOOK TITLEEEEE </p>

		<div class="code-block">
		    <pre><code class="language-r">
			
		# CODE HHHHEEERRRRR 
		# CODE HHHHEEERRRRR 

		    </code></pre>
		</div>
		<!-- ======================== CODE END ============================ -->

		
                  
<!-- ################################################################################### --> 






	  

    <!-- Prism.js library for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
	  
    <!-- Load R language support for Prism -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-r.min.js"></script>


	  
/*  =============================================================================================================   */ 
/*  ====================== To highlight the figure or caption when a user clicks on the link:  ================   */ 
	    /*  ====================== Step 2: Add JavaScript to apply the class  ================   */ 
	<script>
	  function highlightFigure(figureId) {
	    var figureCaption = document.getElementById("figure-caption-" + figureId);
	    figureCaption.classList.add('highlight');
	    setTimeout(function() {
	      figureCaption.classList.remove('highlight');
	    }, 2000);  // Highlight lasts for 5 seconds
	  }
	</script>  
/*  =============================================================================================================   */ 


 
	  
</body>
</html> 
